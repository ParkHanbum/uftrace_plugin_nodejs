// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ThreadDump.proto

#ifndef PROTOBUF_INCLUDED_ThreadDump_2eproto
#define PROTOBUF_INCLUDED_ThreadDump_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ThreadDump_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_ThreadDump_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_ThreadDump_2eproto();
namespace v1 {
class PActiveThreadDump;
class PActiveThreadDumpDefaultTypeInternal;
extern PActiveThreadDumpDefaultTypeInternal _PActiveThreadDump_default_instance_;
class PActiveThreadLightDump;
class PActiveThreadLightDumpDefaultTypeInternal;
extern PActiveThreadLightDumpDefaultTypeInternal _PActiveThreadLightDump_default_instance_;
class PMonitorInfo;
class PMonitorInfoDefaultTypeInternal;
extern PMonitorInfoDefaultTypeInternal _PMonitorInfo_default_instance_;
class PThreadDump;
class PThreadDumpDefaultTypeInternal;
extern PThreadDumpDefaultTypeInternal _PThreadDump_default_instance_;
class PThreadLightDump;
class PThreadLightDumpDefaultTypeInternal;
extern PThreadLightDumpDefaultTypeInternal _PThreadLightDump_default_instance_;
}  // namespace v1
namespace google {
namespace protobuf {
template<> ::v1::PActiveThreadDump* Arena::CreateMaybeMessage<::v1::PActiveThreadDump>(Arena*);
template<> ::v1::PActiveThreadLightDump* Arena::CreateMaybeMessage<::v1::PActiveThreadLightDump>(Arena*);
template<> ::v1::PMonitorInfo* Arena::CreateMaybeMessage<::v1::PMonitorInfo>(Arena*);
template<> ::v1::PThreadDump* Arena::CreateMaybeMessage<::v1::PThreadDump>(Arena*);
template<> ::v1::PThreadLightDump* Arena::CreateMaybeMessage<::v1::PThreadLightDump>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace v1 {

enum PThreadState {
  THREAD_STATE_NEW = 0,
  THREAD_STATE_RUNNABLE = 1,
  THREAD_STATE_BLOCKED = 2,
  THREAD_STATE_WAITING = 3,
  THREAD_STATE_TIMED_WAITING = 4,
  THREAD_STATE_TERMINATED = 5,
  THREAD_STATE_UNKNOWN = 6,
  PThreadState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  PThreadState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool PThreadState_IsValid(int value);
const PThreadState PThreadState_MIN = THREAD_STATE_NEW;
const PThreadState PThreadState_MAX = THREAD_STATE_UNKNOWN;
const int PThreadState_ARRAYSIZE = PThreadState_MAX + 1;

const ::google::protobuf::EnumDescriptor* PThreadState_descriptor();
inline const ::std::string& PThreadState_Name(PThreadState value) {
  return ::google::protobuf::internal::NameOfEnum(
    PThreadState_descriptor(), value);
}
inline bool PThreadState_Parse(
    const ::std::string& name, PThreadState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PThreadState>(
    PThreadState_descriptor(), name, value);
}
enum PThreadDumpType {
  TARGET = 0,
  PENDING = 1,
  PThreadDumpType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  PThreadDumpType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool PThreadDumpType_IsValid(int value);
const PThreadDumpType PThreadDumpType_MIN = TARGET;
const PThreadDumpType PThreadDumpType_MAX = PENDING;
const int PThreadDumpType_ARRAYSIZE = PThreadDumpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PThreadDumpType_descriptor();
inline const ::std::string& PThreadDumpType_Name(PThreadDumpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PThreadDumpType_descriptor(), value);
}
inline bool PThreadDumpType_Parse(
    const ::std::string& name, PThreadDumpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PThreadDumpType>(
    PThreadDumpType_descriptor(), name, value);
}
// ===================================================================

class PMonitorInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PMonitorInfo) */ {
 public:
  PMonitorInfo();
  virtual ~PMonitorInfo();

  PMonitorInfo(const PMonitorInfo& from);

  inline PMonitorInfo& operator=(const PMonitorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PMonitorInfo(PMonitorInfo&& from) noexcept
    : PMonitorInfo() {
    *this = ::std::move(from);
  }

  inline PMonitorInfo& operator=(PMonitorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PMonitorInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PMonitorInfo* internal_default_instance() {
    return reinterpret_cast<const PMonitorInfo*>(
               &_PMonitorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PMonitorInfo* other);
  friend void swap(PMonitorInfo& a, PMonitorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PMonitorInfo* New() const final {
    return CreateMaybeMessage<PMonitorInfo>(nullptr);
  }

  PMonitorInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PMonitorInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PMonitorInfo& from);
  void MergeFrom(const PMonitorInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PMonitorInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string stackFrame = 2;
  void clear_stackframe();
  static const int kStackFrameFieldNumber = 2;
  const ::std::string& stackframe() const;
  void set_stackframe(const ::std::string& value);
  #if LANG_CXX11
  void set_stackframe(::std::string&& value);
  #endif
  void set_stackframe(const char* value);
  void set_stackframe(const char* value, size_t size);
  ::std::string* mutable_stackframe();
  ::std::string* release_stackframe();
  void set_allocated_stackframe(::std::string* stackframe);

  // int32 stackDepth = 1;
  void clear_stackdepth();
  static const int kStackDepthFieldNumber = 1;
  ::google::protobuf::int32 stackdepth() const;
  void set_stackdepth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:v1.PMonitorInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr stackframe_;
  ::google::protobuf::int32 stackdepth_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ThreadDump_2eproto;
};
// -------------------------------------------------------------------

class PThreadDump final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PThreadDump) */ {
 public:
  PThreadDump();
  virtual ~PThreadDump();

  PThreadDump(const PThreadDump& from);

  inline PThreadDump& operator=(const PThreadDump& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PThreadDump(PThreadDump&& from) noexcept
    : PThreadDump() {
    *this = ::std::move(from);
  }

  inline PThreadDump& operator=(PThreadDump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PThreadDump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PThreadDump* internal_default_instance() {
    return reinterpret_cast<const PThreadDump*>(
               &_PThreadDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PThreadDump* other);
  friend void swap(PThreadDump& a, PThreadDump& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PThreadDump* New() const final {
    return CreateMaybeMessage<PThreadDump>(nullptr);
  }

  PThreadDump* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PThreadDump>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PThreadDump& from);
  void MergeFrom(const PThreadDump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PThreadDump* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string stackTrace = 13;
  int stacktrace_size() const;
  void clear_stacktrace();
  static const int kStackTraceFieldNumber = 13;
  const ::std::string& stacktrace(int index) const;
  ::std::string* mutable_stacktrace(int index);
  void set_stacktrace(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_stacktrace(int index, ::std::string&& value);
  #endif
  void set_stacktrace(int index, const char* value);
  void set_stacktrace(int index, const char* value, size_t size);
  ::std::string* add_stacktrace();
  void add_stacktrace(const ::std::string& value);
  #if LANG_CXX11
  void add_stacktrace(::std::string&& value);
  #endif
  void add_stacktrace(const char* value);
  void add_stacktrace(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& stacktrace() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_stacktrace();

  // repeated .v1.PMonitorInfo lockedMonitor = 14;
  int lockedmonitor_size() const;
  void clear_lockedmonitor();
  static const int kLockedMonitorFieldNumber = 14;
  ::v1::PMonitorInfo* mutable_lockedmonitor(int index);
  ::google::protobuf::RepeatedPtrField< ::v1::PMonitorInfo >*
      mutable_lockedmonitor();
  const ::v1::PMonitorInfo& lockedmonitor(int index) const;
  ::v1::PMonitorInfo* add_lockedmonitor();
  const ::google::protobuf::RepeatedPtrField< ::v1::PMonitorInfo >&
      lockedmonitor() const;

  // repeated string lockedSynchronizer = 15;
  int lockedsynchronizer_size() const;
  void clear_lockedsynchronizer();
  static const int kLockedSynchronizerFieldNumber = 15;
  const ::std::string& lockedsynchronizer(int index) const;
  ::std::string* mutable_lockedsynchronizer(int index);
  void set_lockedsynchronizer(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_lockedsynchronizer(int index, ::std::string&& value);
  #endif
  void set_lockedsynchronizer(int index, const char* value);
  void set_lockedsynchronizer(int index, const char* value, size_t size);
  ::std::string* add_lockedsynchronizer();
  void add_lockedsynchronizer(const ::std::string& value);
  #if LANG_CXX11
  void add_lockedsynchronizer(::std::string&& value);
  #endif
  void add_lockedsynchronizer(const char* value);
  void add_lockedsynchronizer(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& lockedsynchronizer() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_lockedsynchronizer();

  // string threadName = 1;
  void clear_threadname();
  static const int kThreadNameFieldNumber = 1;
  const ::std::string& threadname() const;
  void set_threadname(const ::std::string& value);
  #if LANG_CXX11
  void set_threadname(::std::string&& value);
  #endif
  void set_threadname(const char* value);
  void set_threadname(const char* value, size_t size);
  ::std::string* mutable_threadname();
  ::std::string* release_threadname();
  void set_allocated_threadname(::std::string* threadname);

  // string lockName = 7;
  void clear_lockname();
  static const int kLockNameFieldNumber = 7;
  const ::std::string& lockname() const;
  void set_lockname(const ::std::string& value);
  #if LANG_CXX11
  void set_lockname(::std::string&& value);
  #endif
  void set_lockname(const char* value);
  void set_lockname(const char* value, size_t size);
  ::std::string* mutable_lockname();
  ::std::string* release_lockname();
  void set_allocated_lockname(::std::string* lockname);

  // string lockOwnerName = 9;
  void clear_lockownername();
  static const int kLockOwnerNameFieldNumber = 9;
  const ::std::string& lockownername() const;
  void set_lockownername(const ::std::string& value);
  #if LANG_CXX11
  void set_lockownername(::std::string&& value);
  #endif
  void set_lockownername(const char* value);
  void set_lockownername(const char* value, size_t size);
  ::std::string* mutable_lockownername();
  ::std::string* release_lockownername();
  void set_allocated_lockownername(::std::string* lockownername);

  // int64 threadId = 2;
  void clear_threadid();
  static const int kThreadIdFieldNumber = 2;
  ::google::protobuf::int64 threadid() const;
  void set_threadid(::google::protobuf::int64 value);

  // int64 blockedTime = 3;
  void clear_blockedtime();
  static const int kBlockedTimeFieldNumber = 3;
  ::google::protobuf::int64 blockedtime() const;
  void set_blockedtime(::google::protobuf::int64 value);

  // int64 blockedCount = 4;
  void clear_blockedcount();
  static const int kBlockedCountFieldNumber = 4;
  ::google::protobuf::int64 blockedcount() const;
  void set_blockedcount(::google::protobuf::int64 value);

  // int64 waitedTime = 5;
  void clear_waitedtime();
  static const int kWaitedTimeFieldNumber = 5;
  ::google::protobuf::int64 waitedtime() const;
  void set_waitedtime(::google::protobuf::int64 value);

  // int64 waitedCount = 6;
  void clear_waitedcount();
  static const int kWaitedCountFieldNumber = 6;
  ::google::protobuf::int64 waitedcount() const;
  void set_waitedcount(::google::protobuf::int64 value);

  // int64 lockOwnerId = 8;
  void clear_lockownerid();
  static const int kLockOwnerIdFieldNumber = 8;
  ::google::protobuf::int64 lockownerid() const;
  void set_lockownerid(::google::protobuf::int64 value);

  // bool inNative = 10;
  void clear_innative();
  static const int kInNativeFieldNumber = 10;
  bool innative() const;
  void set_innative(bool value);

  // bool suspended = 11;
  void clear_suspended();
  static const int kSuspendedFieldNumber = 11;
  bool suspended() const;
  void set_suspended(bool value);

  // .v1.PThreadState threadState = 12;
  void clear_threadstate();
  static const int kThreadStateFieldNumber = 12;
  ::v1::PThreadState threadstate() const;
  void set_threadstate(::v1::PThreadState value);

  // @@protoc_insertion_point(class_scope:v1.PThreadDump)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> stacktrace_;
  ::google::protobuf::RepeatedPtrField< ::v1::PMonitorInfo > lockedmonitor_;
  ::google::protobuf::RepeatedPtrField<::std::string> lockedsynchronizer_;
  ::google::protobuf::internal::ArenaStringPtr threadname_;
  ::google::protobuf::internal::ArenaStringPtr lockname_;
  ::google::protobuf::internal::ArenaStringPtr lockownername_;
  ::google::protobuf::int64 threadid_;
  ::google::protobuf::int64 blockedtime_;
  ::google::protobuf::int64 blockedcount_;
  ::google::protobuf::int64 waitedtime_;
  ::google::protobuf::int64 waitedcount_;
  ::google::protobuf::int64 lockownerid_;
  bool innative_;
  bool suspended_;
  int threadstate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ThreadDump_2eproto;
};
// -------------------------------------------------------------------

class PThreadLightDump final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PThreadLightDump) */ {
 public:
  PThreadLightDump();
  virtual ~PThreadLightDump();

  PThreadLightDump(const PThreadLightDump& from);

  inline PThreadLightDump& operator=(const PThreadLightDump& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PThreadLightDump(PThreadLightDump&& from) noexcept
    : PThreadLightDump() {
    *this = ::std::move(from);
  }

  inline PThreadLightDump& operator=(PThreadLightDump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PThreadLightDump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PThreadLightDump* internal_default_instance() {
    return reinterpret_cast<const PThreadLightDump*>(
               &_PThreadLightDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PThreadLightDump* other);
  friend void swap(PThreadLightDump& a, PThreadLightDump& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PThreadLightDump* New() const final {
    return CreateMaybeMessage<PThreadLightDump>(nullptr);
  }

  PThreadLightDump* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PThreadLightDump>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PThreadLightDump& from);
  void MergeFrom(const PThreadLightDump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PThreadLightDump* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string threadName = 1;
  void clear_threadname();
  static const int kThreadNameFieldNumber = 1;
  const ::std::string& threadname() const;
  void set_threadname(const ::std::string& value);
  #if LANG_CXX11
  void set_threadname(::std::string&& value);
  #endif
  void set_threadname(const char* value);
  void set_threadname(const char* value, size_t size);
  ::std::string* mutable_threadname();
  ::std::string* release_threadname();
  void set_allocated_threadname(::std::string* threadname);

  // int64 threadId = 2;
  void clear_threadid();
  static const int kThreadIdFieldNumber = 2;
  ::google::protobuf::int64 threadid() const;
  void set_threadid(::google::protobuf::int64 value);

  // .v1.PThreadState threadState = 3;
  void clear_threadstate();
  static const int kThreadStateFieldNumber = 3;
  ::v1::PThreadState threadstate() const;
  void set_threadstate(::v1::PThreadState value);

  // @@protoc_insertion_point(class_scope:v1.PThreadLightDump)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr threadname_;
  ::google::protobuf::int64 threadid_;
  int threadstate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ThreadDump_2eproto;
};
// -------------------------------------------------------------------

class PActiveThreadDump final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PActiveThreadDump) */ {
 public:
  PActiveThreadDump();
  virtual ~PActiveThreadDump();

  PActiveThreadDump(const PActiveThreadDump& from);

  inline PActiveThreadDump& operator=(const PActiveThreadDump& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PActiveThreadDump(PActiveThreadDump&& from) noexcept
    : PActiveThreadDump() {
    *this = ::std::move(from);
  }

  inline PActiveThreadDump& operator=(PActiveThreadDump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PActiveThreadDump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PActiveThreadDump* internal_default_instance() {
    return reinterpret_cast<const PActiveThreadDump*>(
               &_PActiveThreadDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PActiveThreadDump* other);
  friend void swap(PActiveThreadDump& a, PActiveThreadDump& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PActiveThreadDump* New() const final {
    return CreateMaybeMessage<PActiveThreadDump>(nullptr);
  }

  PActiveThreadDump* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PActiveThreadDump>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PActiveThreadDump& from);
  void MergeFrom(const PActiveThreadDump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PActiveThreadDump* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string transactionId = 5;
  void clear_transactionid();
  static const int kTransactionIdFieldNumber = 5;
  const ::std::string& transactionid() const;
  void set_transactionid(const ::std::string& value);
  #if LANG_CXX11
  void set_transactionid(::std::string&& value);
  #endif
  void set_transactionid(const char* value);
  void set_transactionid(const char* value, size_t size);
  ::std::string* mutable_transactionid();
  ::std::string* release_transactionid();
  void set_allocated_transactionid(::std::string* transactionid);

  // string entryPoint = 6;
  void clear_entrypoint();
  static const int kEntryPointFieldNumber = 6;
  const ::std::string& entrypoint() const;
  void set_entrypoint(const ::std::string& value);
  #if LANG_CXX11
  void set_entrypoint(::std::string&& value);
  #endif
  void set_entrypoint(const char* value);
  void set_entrypoint(const char* value, size_t size);
  ::std::string* mutable_entrypoint();
  ::std::string* release_entrypoint();
  void set_allocated_entrypoint(::std::string* entrypoint);

  // .v1.PThreadDump threadDump = 3;
  bool has_threaddump() const;
  void clear_threaddump();
  static const int kThreadDumpFieldNumber = 3;
  const ::v1::PThreadDump& threaddump() const;
  ::v1::PThreadDump* release_threaddump();
  ::v1::PThreadDump* mutable_threaddump();
  void set_allocated_threaddump(::v1::PThreadDump* threaddump);

  // int64 startTime = 1;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  ::google::protobuf::int64 starttime() const;
  void set_starttime(::google::protobuf::int64 value);

  // int64 localTraceId = 2;
  void clear_localtraceid();
  static const int kLocalTraceIdFieldNumber = 2;
  ::google::protobuf::int64 localtraceid() const;
  void set_localtraceid(::google::protobuf::int64 value);

  // bool sampled = 4;
  void clear_sampled();
  static const int kSampledFieldNumber = 4;
  bool sampled() const;
  void set_sampled(bool value);

  // @@protoc_insertion_point(class_scope:v1.PActiveThreadDump)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr transactionid_;
  ::google::protobuf::internal::ArenaStringPtr entrypoint_;
  ::v1::PThreadDump* threaddump_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 localtraceid_;
  bool sampled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ThreadDump_2eproto;
};
// -------------------------------------------------------------------

class PActiveThreadLightDump final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PActiveThreadLightDump) */ {
 public:
  PActiveThreadLightDump();
  virtual ~PActiveThreadLightDump();

  PActiveThreadLightDump(const PActiveThreadLightDump& from);

  inline PActiveThreadLightDump& operator=(const PActiveThreadLightDump& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PActiveThreadLightDump(PActiveThreadLightDump&& from) noexcept
    : PActiveThreadLightDump() {
    *this = ::std::move(from);
  }

  inline PActiveThreadLightDump& operator=(PActiveThreadLightDump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PActiveThreadLightDump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PActiveThreadLightDump* internal_default_instance() {
    return reinterpret_cast<const PActiveThreadLightDump*>(
               &_PActiveThreadLightDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PActiveThreadLightDump* other);
  friend void swap(PActiveThreadLightDump& a, PActiveThreadLightDump& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PActiveThreadLightDump* New() const final {
    return CreateMaybeMessage<PActiveThreadLightDump>(nullptr);
  }

  PActiveThreadLightDump* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PActiveThreadLightDump>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PActiveThreadLightDump& from);
  void MergeFrom(const PActiveThreadLightDump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PActiveThreadLightDump* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string transactionId = 5;
  void clear_transactionid();
  static const int kTransactionIdFieldNumber = 5;
  const ::std::string& transactionid() const;
  void set_transactionid(const ::std::string& value);
  #if LANG_CXX11
  void set_transactionid(::std::string&& value);
  #endif
  void set_transactionid(const char* value);
  void set_transactionid(const char* value, size_t size);
  ::std::string* mutable_transactionid();
  ::std::string* release_transactionid();
  void set_allocated_transactionid(::std::string* transactionid);

  // string entryPoint = 6;
  void clear_entrypoint();
  static const int kEntryPointFieldNumber = 6;
  const ::std::string& entrypoint() const;
  void set_entrypoint(const ::std::string& value);
  #if LANG_CXX11
  void set_entrypoint(::std::string&& value);
  #endif
  void set_entrypoint(const char* value);
  void set_entrypoint(const char* value, size_t size);
  ::std::string* mutable_entrypoint();
  ::std::string* release_entrypoint();
  void set_allocated_entrypoint(::std::string* entrypoint);

  // .v1.PThreadLightDump threadDump = 3;
  bool has_threaddump() const;
  void clear_threaddump();
  static const int kThreadDumpFieldNumber = 3;
  const ::v1::PThreadLightDump& threaddump() const;
  ::v1::PThreadLightDump* release_threaddump();
  ::v1::PThreadLightDump* mutable_threaddump();
  void set_allocated_threaddump(::v1::PThreadLightDump* threaddump);

  // int64 startTime = 1;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  ::google::protobuf::int64 starttime() const;
  void set_starttime(::google::protobuf::int64 value);

  // int64 localTraceId = 2;
  void clear_localtraceid();
  static const int kLocalTraceIdFieldNumber = 2;
  ::google::protobuf::int64 localtraceid() const;
  void set_localtraceid(::google::protobuf::int64 value);

  // bool sampled = 4;
  void clear_sampled();
  static const int kSampledFieldNumber = 4;
  bool sampled() const;
  void set_sampled(bool value);

  // @@protoc_insertion_point(class_scope:v1.PActiveThreadLightDump)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr transactionid_;
  ::google::protobuf::internal::ArenaStringPtr entrypoint_;
  ::v1::PThreadLightDump* threaddump_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 localtraceid_;
  bool sampled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ThreadDump_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PMonitorInfo

// int32 stackDepth = 1;
inline void PMonitorInfo::clear_stackdepth() {
  stackdepth_ = 0;
}
inline ::google::protobuf::int32 PMonitorInfo::stackdepth() const {
  // @@protoc_insertion_point(field_get:v1.PMonitorInfo.stackDepth)
  return stackdepth_;
}
inline void PMonitorInfo::set_stackdepth(::google::protobuf::int32 value) {
  
  stackdepth_ = value;
  // @@protoc_insertion_point(field_set:v1.PMonitorInfo.stackDepth)
}

// string stackFrame = 2;
inline void PMonitorInfo::clear_stackframe() {
  stackframe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PMonitorInfo::stackframe() const {
  // @@protoc_insertion_point(field_get:v1.PMonitorInfo.stackFrame)
  return stackframe_.GetNoArena();
}
inline void PMonitorInfo::set_stackframe(const ::std::string& value) {
  
  stackframe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PMonitorInfo.stackFrame)
}
#if LANG_CXX11
inline void PMonitorInfo::set_stackframe(::std::string&& value) {
  
  stackframe_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PMonitorInfo.stackFrame)
}
#endif
inline void PMonitorInfo::set_stackframe(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  stackframe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PMonitorInfo.stackFrame)
}
inline void PMonitorInfo::set_stackframe(const char* value, size_t size) {
  
  stackframe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PMonitorInfo.stackFrame)
}
inline ::std::string* PMonitorInfo::mutable_stackframe() {
  
  // @@protoc_insertion_point(field_mutable:v1.PMonitorInfo.stackFrame)
  return stackframe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PMonitorInfo::release_stackframe() {
  // @@protoc_insertion_point(field_release:v1.PMonitorInfo.stackFrame)
  
  return stackframe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PMonitorInfo::set_allocated_stackframe(::std::string* stackframe) {
  if (stackframe != nullptr) {
    
  } else {
    
  }
  stackframe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stackframe);
  // @@protoc_insertion_point(field_set_allocated:v1.PMonitorInfo.stackFrame)
}

// -------------------------------------------------------------------

// PThreadDump

// string threadName = 1;
inline void PThreadDump::clear_threadname() {
  threadname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PThreadDump::threadname() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.threadName)
  return threadname_.GetNoArena();
}
inline void PThreadDump::set_threadname(const ::std::string& value) {
  
  threadname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PThreadDump.threadName)
}
#if LANG_CXX11
inline void PThreadDump::set_threadname(::std::string&& value) {
  
  threadname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PThreadDump.threadName)
}
#endif
inline void PThreadDump::set_threadname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  threadname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PThreadDump.threadName)
}
inline void PThreadDump::set_threadname(const char* value, size_t size) {
  
  threadname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PThreadDump.threadName)
}
inline ::std::string* PThreadDump::mutable_threadname() {
  
  // @@protoc_insertion_point(field_mutable:v1.PThreadDump.threadName)
  return threadname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PThreadDump::release_threadname() {
  // @@protoc_insertion_point(field_release:v1.PThreadDump.threadName)
  
  return threadname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PThreadDump::set_allocated_threadname(::std::string* threadname) {
  if (threadname != nullptr) {
    
  } else {
    
  }
  threadname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), threadname);
  // @@protoc_insertion_point(field_set_allocated:v1.PThreadDump.threadName)
}

// int64 threadId = 2;
inline void PThreadDump::clear_threadid() {
  threadid_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PThreadDump::threadid() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.threadId)
  return threadid_;
}
inline void PThreadDump::set_threadid(::google::protobuf::int64 value) {
  
  threadid_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadDump.threadId)
}

// int64 blockedTime = 3;
inline void PThreadDump::clear_blockedtime() {
  blockedtime_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PThreadDump::blockedtime() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.blockedTime)
  return blockedtime_;
}
inline void PThreadDump::set_blockedtime(::google::protobuf::int64 value) {
  
  blockedtime_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadDump.blockedTime)
}

// int64 blockedCount = 4;
inline void PThreadDump::clear_blockedcount() {
  blockedcount_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PThreadDump::blockedcount() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.blockedCount)
  return blockedcount_;
}
inline void PThreadDump::set_blockedcount(::google::protobuf::int64 value) {
  
  blockedcount_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadDump.blockedCount)
}

// int64 waitedTime = 5;
inline void PThreadDump::clear_waitedtime() {
  waitedtime_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PThreadDump::waitedtime() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.waitedTime)
  return waitedtime_;
}
inline void PThreadDump::set_waitedtime(::google::protobuf::int64 value) {
  
  waitedtime_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadDump.waitedTime)
}

// int64 waitedCount = 6;
inline void PThreadDump::clear_waitedcount() {
  waitedcount_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PThreadDump::waitedcount() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.waitedCount)
  return waitedcount_;
}
inline void PThreadDump::set_waitedcount(::google::protobuf::int64 value) {
  
  waitedcount_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadDump.waitedCount)
}

// string lockName = 7;
inline void PThreadDump::clear_lockname() {
  lockname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PThreadDump::lockname() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.lockName)
  return lockname_.GetNoArena();
}
inline void PThreadDump::set_lockname(const ::std::string& value) {
  
  lockname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PThreadDump.lockName)
}
#if LANG_CXX11
inline void PThreadDump::set_lockname(::std::string&& value) {
  
  lockname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PThreadDump.lockName)
}
#endif
inline void PThreadDump::set_lockname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  lockname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PThreadDump.lockName)
}
inline void PThreadDump::set_lockname(const char* value, size_t size) {
  
  lockname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PThreadDump.lockName)
}
inline ::std::string* PThreadDump::mutable_lockname() {
  
  // @@protoc_insertion_point(field_mutable:v1.PThreadDump.lockName)
  return lockname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PThreadDump::release_lockname() {
  // @@protoc_insertion_point(field_release:v1.PThreadDump.lockName)
  
  return lockname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PThreadDump::set_allocated_lockname(::std::string* lockname) {
  if (lockname != nullptr) {
    
  } else {
    
  }
  lockname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lockname);
  // @@protoc_insertion_point(field_set_allocated:v1.PThreadDump.lockName)
}

// int64 lockOwnerId = 8;
inline void PThreadDump::clear_lockownerid() {
  lockownerid_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PThreadDump::lockownerid() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.lockOwnerId)
  return lockownerid_;
}
inline void PThreadDump::set_lockownerid(::google::protobuf::int64 value) {
  
  lockownerid_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadDump.lockOwnerId)
}

// string lockOwnerName = 9;
inline void PThreadDump::clear_lockownername() {
  lockownername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PThreadDump::lockownername() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.lockOwnerName)
  return lockownername_.GetNoArena();
}
inline void PThreadDump::set_lockownername(const ::std::string& value) {
  
  lockownername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PThreadDump.lockOwnerName)
}
#if LANG_CXX11
inline void PThreadDump::set_lockownername(::std::string&& value) {
  
  lockownername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PThreadDump.lockOwnerName)
}
#endif
inline void PThreadDump::set_lockownername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  lockownername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PThreadDump.lockOwnerName)
}
inline void PThreadDump::set_lockownername(const char* value, size_t size) {
  
  lockownername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PThreadDump.lockOwnerName)
}
inline ::std::string* PThreadDump::mutable_lockownername() {
  
  // @@protoc_insertion_point(field_mutable:v1.PThreadDump.lockOwnerName)
  return lockownername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PThreadDump::release_lockownername() {
  // @@protoc_insertion_point(field_release:v1.PThreadDump.lockOwnerName)
  
  return lockownername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PThreadDump::set_allocated_lockownername(::std::string* lockownername) {
  if (lockownername != nullptr) {
    
  } else {
    
  }
  lockownername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lockownername);
  // @@protoc_insertion_point(field_set_allocated:v1.PThreadDump.lockOwnerName)
}

// bool inNative = 10;
inline void PThreadDump::clear_innative() {
  innative_ = false;
}
inline bool PThreadDump::innative() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.inNative)
  return innative_;
}
inline void PThreadDump::set_innative(bool value) {
  
  innative_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadDump.inNative)
}

// bool suspended = 11;
inline void PThreadDump::clear_suspended() {
  suspended_ = false;
}
inline bool PThreadDump::suspended() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.suspended)
  return suspended_;
}
inline void PThreadDump::set_suspended(bool value) {
  
  suspended_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadDump.suspended)
}

// .v1.PThreadState threadState = 12;
inline void PThreadDump::clear_threadstate() {
  threadstate_ = 0;
}
inline ::v1::PThreadState PThreadDump::threadstate() const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.threadState)
  return static_cast< ::v1::PThreadState >(threadstate_);
}
inline void PThreadDump::set_threadstate(::v1::PThreadState value) {
  
  threadstate_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadDump.threadState)
}

// repeated string stackTrace = 13;
inline int PThreadDump::stacktrace_size() const {
  return stacktrace_.size();
}
inline void PThreadDump::clear_stacktrace() {
  stacktrace_.Clear();
}
inline const ::std::string& PThreadDump::stacktrace(int index) const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.stackTrace)
  return stacktrace_.Get(index);
}
inline ::std::string* PThreadDump::mutable_stacktrace(int index) {
  // @@protoc_insertion_point(field_mutable:v1.PThreadDump.stackTrace)
  return stacktrace_.Mutable(index);
}
inline void PThreadDump::set_stacktrace(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:v1.PThreadDump.stackTrace)
  stacktrace_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PThreadDump::set_stacktrace(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:v1.PThreadDump.stackTrace)
  stacktrace_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PThreadDump::set_stacktrace(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  stacktrace_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v1.PThreadDump.stackTrace)
}
inline void PThreadDump::set_stacktrace(int index, const char* value, size_t size) {
  stacktrace_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v1.PThreadDump.stackTrace)
}
inline ::std::string* PThreadDump::add_stacktrace() {
  // @@protoc_insertion_point(field_add_mutable:v1.PThreadDump.stackTrace)
  return stacktrace_.Add();
}
inline void PThreadDump::add_stacktrace(const ::std::string& value) {
  stacktrace_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v1.PThreadDump.stackTrace)
}
#if LANG_CXX11
inline void PThreadDump::add_stacktrace(::std::string&& value) {
  stacktrace_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v1.PThreadDump.stackTrace)
}
#endif
inline void PThreadDump::add_stacktrace(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  stacktrace_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v1.PThreadDump.stackTrace)
}
inline void PThreadDump::add_stacktrace(const char* value, size_t size) {
  stacktrace_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v1.PThreadDump.stackTrace)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PThreadDump::stacktrace() const {
  // @@protoc_insertion_point(field_list:v1.PThreadDump.stackTrace)
  return stacktrace_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
PThreadDump::mutable_stacktrace() {
  // @@protoc_insertion_point(field_mutable_list:v1.PThreadDump.stackTrace)
  return &stacktrace_;
}

// repeated .v1.PMonitorInfo lockedMonitor = 14;
inline int PThreadDump::lockedmonitor_size() const {
  return lockedmonitor_.size();
}
inline void PThreadDump::clear_lockedmonitor() {
  lockedmonitor_.Clear();
}
inline ::v1::PMonitorInfo* PThreadDump::mutable_lockedmonitor(int index) {
  // @@protoc_insertion_point(field_mutable:v1.PThreadDump.lockedMonitor)
  return lockedmonitor_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::v1::PMonitorInfo >*
PThreadDump::mutable_lockedmonitor() {
  // @@protoc_insertion_point(field_mutable_list:v1.PThreadDump.lockedMonitor)
  return &lockedmonitor_;
}
inline const ::v1::PMonitorInfo& PThreadDump::lockedmonitor(int index) const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.lockedMonitor)
  return lockedmonitor_.Get(index);
}
inline ::v1::PMonitorInfo* PThreadDump::add_lockedmonitor() {
  // @@protoc_insertion_point(field_add:v1.PThreadDump.lockedMonitor)
  return lockedmonitor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::v1::PMonitorInfo >&
PThreadDump::lockedmonitor() const {
  // @@protoc_insertion_point(field_list:v1.PThreadDump.lockedMonitor)
  return lockedmonitor_;
}

// repeated string lockedSynchronizer = 15;
inline int PThreadDump::lockedsynchronizer_size() const {
  return lockedsynchronizer_.size();
}
inline void PThreadDump::clear_lockedsynchronizer() {
  lockedsynchronizer_.Clear();
}
inline const ::std::string& PThreadDump::lockedsynchronizer(int index) const {
  // @@protoc_insertion_point(field_get:v1.PThreadDump.lockedSynchronizer)
  return lockedsynchronizer_.Get(index);
}
inline ::std::string* PThreadDump::mutable_lockedsynchronizer(int index) {
  // @@protoc_insertion_point(field_mutable:v1.PThreadDump.lockedSynchronizer)
  return lockedsynchronizer_.Mutable(index);
}
inline void PThreadDump::set_lockedsynchronizer(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:v1.PThreadDump.lockedSynchronizer)
  lockedsynchronizer_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PThreadDump::set_lockedsynchronizer(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:v1.PThreadDump.lockedSynchronizer)
  lockedsynchronizer_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PThreadDump::set_lockedsynchronizer(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lockedsynchronizer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v1.PThreadDump.lockedSynchronizer)
}
inline void PThreadDump::set_lockedsynchronizer(int index, const char* value, size_t size) {
  lockedsynchronizer_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v1.PThreadDump.lockedSynchronizer)
}
inline ::std::string* PThreadDump::add_lockedsynchronizer() {
  // @@protoc_insertion_point(field_add_mutable:v1.PThreadDump.lockedSynchronizer)
  return lockedsynchronizer_.Add();
}
inline void PThreadDump::add_lockedsynchronizer(const ::std::string& value) {
  lockedsynchronizer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v1.PThreadDump.lockedSynchronizer)
}
#if LANG_CXX11
inline void PThreadDump::add_lockedsynchronizer(::std::string&& value) {
  lockedsynchronizer_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v1.PThreadDump.lockedSynchronizer)
}
#endif
inline void PThreadDump::add_lockedsynchronizer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lockedsynchronizer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v1.PThreadDump.lockedSynchronizer)
}
inline void PThreadDump::add_lockedsynchronizer(const char* value, size_t size) {
  lockedsynchronizer_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v1.PThreadDump.lockedSynchronizer)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PThreadDump::lockedsynchronizer() const {
  // @@protoc_insertion_point(field_list:v1.PThreadDump.lockedSynchronizer)
  return lockedsynchronizer_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
PThreadDump::mutable_lockedsynchronizer() {
  // @@protoc_insertion_point(field_mutable_list:v1.PThreadDump.lockedSynchronizer)
  return &lockedsynchronizer_;
}

// -------------------------------------------------------------------

// PThreadLightDump

// string threadName = 1;
inline void PThreadLightDump::clear_threadname() {
  threadname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PThreadLightDump::threadname() const {
  // @@protoc_insertion_point(field_get:v1.PThreadLightDump.threadName)
  return threadname_.GetNoArena();
}
inline void PThreadLightDump::set_threadname(const ::std::string& value) {
  
  threadname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PThreadLightDump.threadName)
}
#if LANG_CXX11
inline void PThreadLightDump::set_threadname(::std::string&& value) {
  
  threadname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PThreadLightDump.threadName)
}
#endif
inline void PThreadLightDump::set_threadname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  threadname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PThreadLightDump.threadName)
}
inline void PThreadLightDump::set_threadname(const char* value, size_t size) {
  
  threadname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PThreadLightDump.threadName)
}
inline ::std::string* PThreadLightDump::mutable_threadname() {
  
  // @@protoc_insertion_point(field_mutable:v1.PThreadLightDump.threadName)
  return threadname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PThreadLightDump::release_threadname() {
  // @@protoc_insertion_point(field_release:v1.PThreadLightDump.threadName)
  
  return threadname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PThreadLightDump::set_allocated_threadname(::std::string* threadname) {
  if (threadname != nullptr) {
    
  } else {
    
  }
  threadname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), threadname);
  // @@protoc_insertion_point(field_set_allocated:v1.PThreadLightDump.threadName)
}

// int64 threadId = 2;
inline void PThreadLightDump::clear_threadid() {
  threadid_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PThreadLightDump::threadid() const {
  // @@protoc_insertion_point(field_get:v1.PThreadLightDump.threadId)
  return threadid_;
}
inline void PThreadLightDump::set_threadid(::google::protobuf::int64 value) {
  
  threadid_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadLightDump.threadId)
}

// .v1.PThreadState threadState = 3;
inline void PThreadLightDump::clear_threadstate() {
  threadstate_ = 0;
}
inline ::v1::PThreadState PThreadLightDump::threadstate() const {
  // @@protoc_insertion_point(field_get:v1.PThreadLightDump.threadState)
  return static_cast< ::v1::PThreadState >(threadstate_);
}
inline void PThreadLightDump::set_threadstate(::v1::PThreadState value) {
  
  threadstate_ = value;
  // @@protoc_insertion_point(field_set:v1.PThreadLightDump.threadState)
}

// -------------------------------------------------------------------

// PActiveThreadDump

// int64 startTime = 1;
inline void PActiveThreadDump::clear_starttime() {
  starttime_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PActiveThreadDump::starttime() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadDump.startTime)
  return starttime_;
}
inline void PActiveThreadDump::set_starttime(::google::protobuf::int64 value) {
  
  starttime_ = value;
  // @@protoc_insertion_point(field_set:v1.PActiveThreadDump.startTime)
}

// int64 localTraceId = 2;
inline void PActiveThreadDump::clear_localtraceid() {
  localtraceid_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PActiveThreadDump::localtraceid() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadDump.localTraceId)
  return localtraceid_;
}
inline void PActiveThreadDump::set_localtraceid(::google::protobuf::int64 value) {
  
  localtraceid_ = value;
  // @@protoc_insertion_point(field_set:v1.PActiveThreadDump.localTraceId)
}

// .v1.PThreadDump threadDump = 3;
inline bool PActiveThreadDump::has_threaddump() const {
  return this != internal_default_instance() && threaddump_ != nullptr;
}
inline void PActiveThreadDump::clear_threaddump() {
  if (GetArenaNoVirtual() == nullptr && threaddump_ != nullptr) {
    delete threaddump_;
  }
  threaddump_ = nullptr;
}
inline const ::v1::PThreadDump& PActiveThreadDump::threaddump() const {
  const ::v1::PThreadDump* p = threaddump_;
  // @@protoc_insertion_point(field_get:v1.PActiveThreadDump.threadDump)
  return p != nullptr ? *p : *reinterpret_cast<const ::v1::PThreadDump*>(
      &::v1::_PThreadDump_default_instance_);
}
inline ::v1::PThreadDump* PActiveThreadDump::release_threaddump() {
  // @@protoc_insertion_point(field_release:v1.PActiveThreadDump.threadDump)
  
  ::v1::PThreadDump* temp = threaddump_;
  threaddump_ = nullptr;
  return temp;
}
inline ::v1::PThreadDump* PActiveThreadDump::mutable_threaddump() {
  
  if (threaddump_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::PThreadDump>(GetArenaNoVirtual());
    threaddump_ = p;
  }
  // @@protoc_insertion_point(field_mutable:v1.PActiveThreadDump.threadDump)
  return threaddump_;
}
inline void PActiveThreadDump::set_allocated_threaddump(::v1::PThreadDump* threaddump) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete threaddump_;
  }
  if (threaddump) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      threaddump = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, threaddump, submessage_arena);
    }
    
  } else {
    
  }
  threaddump_ = threaddump;
  // @@protoc_insertion_point(field_set_allocated:v1.PActiveThreadDump.threadDump)
}

// bool sampled = 4;
inline void PActiveThreadDump::clear_sampled() {
  sampled_ = false;
}
inline bool PActiveThreadDump::sampled() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadDump.sampled)
  return sampled_;
}
inline void PActiveThreadDump::set_sampled(bool value) {
  
  sampled_ = value;
  // @@protoc_insertion_point(field_set:v1.PActiveThreadDump.sampled)
}

// string transactionId = 5;
inline void PActiveThreadDump::clear_transactionid() {
  transactionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PActiveThreadDump::transactionid() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadDump.transactionId)
  return transactionid_.GetNoArena();
}
inline void PActiveThreadDump::set_transactionid(const ::std::string& value) {
  
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PActiveThreadDump.transactionId)
}
#if LANG_CXX11
inline void PActiveThreadDump::set_transactionid(::std::string&& value) {
  
  transactionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PActiveThreadDump.transactionId)
}
#endif
inline void PActiveThreadDump::set_transactionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PActiveThreadDump.transactionId)
}
inline void PActiveThreadDump::set_transactionid(const char* value, size_t size) {
  
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PActiveThreadDump.transactionId)
}
inline ::std::string* PActiveThreadDump::mutable_transactionid() {
  
  // @@protoc_insertion_point(field_mutable:v1.PActiveThreadDump.transactionId)
  return transactionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PActiveThreadDump::release_transactionid() {
  // @@protoc_insertion_point(field_release:v1.PActiveThreadDump.transactionId)
  
  return transactionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PActiveThreadDump::set_allocated_transactionid(::std::string* transactionid) {
  if (transactionid != nullptr) {
    
  } else {
    
  }
  transactionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transactionid);
  // @@protoc_insertion_point(field_set_allocated:v1.PActiveThreadDump.transactionId)
}

// string entryPoint = 6;
inline void PActiveThreadDump::clear_entrypoint() {
  entrypoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PActiveThreadDump::entrypoint() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadDump.entryPoint)
  return entrypoint_.GetNoArena();
}
inline void PActiveThreadDump::set_entrypoint(const ::std::string& value) {
  
  entrypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PActiveThreadDump.entryPoint)
}
#if LANG_CXX11
inline void PActiveThreadDump::set_entrypoint(::std::string&& value) {
  
  entrypoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PActiveThreadDump.entryPoint)
}
#endif
inline void PActiveThreadDump::set_entrypoint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entrypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PActiveThreadDump.entryPoint)
}
inline void PActiveThreadDump::set_entrypoint(const char* value, size_t size) {
  
  entrypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PActiveThreadDump.entryPoint)
}
inline ::std::string* PActiveThreadDump::mutable_entrypoint() {
  
  // @@protoc_insertion_point(field_mutable:v1.PActiveThreadDump.entryPoint)
  return entrypoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PActiveThreadDump::release_entrypoint() {
  // @@protoc_insertion_point(field_release:v1.PActiveThreadDump.entryPoint)
  
  return entrypoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PActiveThreadDump::set_allocated_entrypoint(::std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entrypoint);
  // @@protoc_insertion_point(field_set_allocated:v1.PActiveThreadDump.entryPoint)
}

// -------------------------------------------------------------------

// PActiveThreadLightDump

// int64 startTime = 1;
inline void PActiveThreadLightDump::clear_starttime() {
  starttime_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PActiveThreadLightDump::starttime() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadLightDump.startTime)
  return starttime_;
}
inline void PActiveThreadLightDump::set_starttime(::google::protobuf::int64 value) {
  
  starttime_ = value;
  // @@protoc_insertion_point(field_set:v1.PActiveThreadLightDump.startTime)
}

// int64 localTraceId = 2;
inline void PActiveThreadLightDump::clear_localtraceid() {
  localtraceid_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PActiveThreadLightDump::localtraceid() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadLightDump.localTraceId)
  return localtraceid_;
}
inline void PActiveThreadLightDump::set_localtraceid(::google::protobuf::int64 value) {
  
  localtraceid_ = value;
  // @@protoc_insertion_point(field_set:v1.PActiveThreadLightDump.localTraceId)
}

// .v1.PThreadLightDump threadDump = 3;
inline bool PActiveThreadLightDump::has_threaddump() const {
  return this != internal_default_instance() && threaddump_ != nullptr;
}
inline void PActiveThreadLightDump::clear_threaddump() {
  if (GetArenaNoVirtual() == nullptr && threaddump_ != nullptr) {
    delete threaddump_;
  }
  threaddump_ = nullptr;
}
inline const ::v1::PThreadLightDump& PActiveThreadLightDump::threaddump() const {
  const ::v1::PThreadLightDump* p = threaddump_;
  // @@protoc_insertion_point(field_get:v1.PActiveThreadLightDump.threadDump)
  return p != nullptr ? *p : *reinterpret_cast<const ::v1::PThreadLightDump*>(
      &::v1::_PThreadLightDump_default_instance_);
}
inline ::v1::PThreadLightDump* PActiveThreadLightDump::release_threaddump() {
  // @@protoc_insertion_point(field_release:v1.PActiveThreadLightDump.threadDump)
  
  ::v1::PThreadLightDump* temp = threaddump_;
  threaddump_ = nullptr;
  return temp;
}
inline ::v1::PThreadLightDump* PActiveThreadLightDump::mutable_threaddump() {
  
  if (threaddump_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::PThreadLightDump>(GetArenaNoVirtual());
    threaddump_ = p;
  }
  // @@protoc_insertion_point(field_mutable:v1.PActiveThreadLightDump.threadDump)
  return threaddump_;
}
inline void PActiveThreadLightDump::set_allocated_threaddump(::v1::PThreadLightDump* threaddump) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete threaddump_;
  }
  if (threaddump) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      threaddump = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, threaddump, submessage_arena);
    }
    
  } else {
    
  }
  threaddump_ = threaddump;
  // @@protoc_insertion_point(field_set_allocated:v1.PActiveThreadLightDump.threadDump)
}

// bool sampled = 4;
inline void PActiveThreadLightDump::clear_sampled() {
  sampled_ = false;
}
inline bool PActiveThreadLightDump::sampled() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadLightDump.sampled)
  return sampled_;
}
inline void PActiveThreadLightDump::set_sampled(bool value) {
  
  sampled_ = value;
  // @@protoc_insertion_point(field_set:v1.PActiveThreadLightDump.sampled)
}

// string transactionId = 5;
inline void PActiveThreadLightDump::clear_transactionid() {
  transactionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PActiveThreadLightDump::transactionid() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadLightDump.transactionId)
  return transactionid_.GetNoArena();
}
inline void PActiveThreadLightDump::set_transactionid(const ::std::string& value) {
  
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PActiveThreadLightDump.transactionId)
}
#if LANG_CXX11
inline void PActiveThreadLightDump::set_transactionid(::std::string&& value) {
  
  transactionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PActiveThreadLightDump.transactionId)
}
#endif
inline void PActiveThreadLightDump::set_transactionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PActiveThreadLightDump.transactionId)
}
inline void PActiveThreadLightDump::set_transactionid(const char* value, size_t size) {
  
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PActiveThreadLightDump.transactionId)
}
inline ::std::string* PActiveThreadLightDump::mutable_transactionid() {
  
  // @@protoc_insertion_point(field_mutable:v1.PActiveThreadLightDump.transactionId)
  return transactionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PActiveThreadLightDump::release_transactionid() {
  // @@protoc_insertion_point(field_release:v1.PActiveThreadLightDump.transactionId)
  
  return transactionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PActiveThreadLightDump::set_allocated_transactionid(::std::string* transactionid) {
  if (transactionid != nullptr) {
    
  } else {
    
  }
  transactionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transactionid);
  // @@protoc_insertion_point(field_set_allocated:v1.PActiveThreadLightDump.transactionId)
}

// string entryPoint = 6;
inline void PActiveThreadLightDump::clear_entrypoint() {
  entrypoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PActiveThreadLightDump::entrypoint() const {
  // @@protoc_insertion_point(field_get:v1.PActiveThreadLightDump.entryPoint)
  return entrypoint_.GetNoArena();
}
inline void PActiveThreadLightDump::set_entrypoint(const ::std::string& value) {
  
  entrypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PActiveThreadLightDump.entryPoint)
}
#if LANG_CXX11
inline void PActiveThreadLightDump::set_entrypoint(::std::string&& value) {
  
  entrypoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PActiveThreadLightDump.entryPoint)
}
#endif
inline void PActiveThreadLightDump::set_entrypoint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entrypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PActiveThreadLightDump.entryPoint)
}
inline void PActiveThreadLightDump::set_entrypoint(const char* value, size_t size) {
  
  entrypoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PActiveThreadLightDump.entryPoint)
}
inline ::std::string* PActiveThreadLightDump::mutable_entrypoint() {
  
  // @@protoc_insertion_point(field_mutable:v1.PActiveThreadLightDump.entryPoint)
  return entrypoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PActiveThreadLightDump::release_entrypoint() {
  // @@protoc_insertion_point(field_release:v1.PActiveThreadLightDump.entryPoint)
  
  return entrypoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PActiveThreadLightDump::set_allocated_entrypoint(::std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entrypoint);
  // @@protoc_insertion_point(field_set_allocated:v1.PActiveThreadLightDump.entryPoint)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::v1::PThreadState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::PThreadState>() {
  return ::v1::PThreadState_descriptor();
}
template <> struct is_proto_enum< ::v1::PThreadDumpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::PThreadDumpType>() {
  return ::v1::PThreadDumpType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_ThreadDump_2eproto
