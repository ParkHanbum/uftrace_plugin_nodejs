// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Cmd.proto

#ifndef PROTOBUF_INCLUDED_Cmd_2eproto
#define PROTOBUF_INCLUDED_Cmd_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "ThreadDump.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Cmd_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_Cmd_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_Cmd_2eproto();
namespace v1 {
class PCmdActiveThreadCount;
class PCmdActiveThreadCountDefaultTypeInternal;
extern PCmdActiveThreadCountDefaultTypeInternal _PCmdActiveThreadCount_default_instance_;
class PCmdActiveThreadCountRes;
class PCmdActiveThreadCountResDefaultTypeInternal;
extern PCmdActiveThreadCountResDefaultTypeInternal _PCmdActiveThreadCountRes_default_instance_;
class PCmdActiveThreadDump;
class PCmdActiveThreadDumpDefaultTypeInternal;
extern PCmdActiveThreadDumpDefaultTypeInternal _PCmdActiveThreadDump_default_instance_;
class PCmdActiveThreadDumpRes;
class PCmdActiveThreadDumpResDefaultTypeInternal;
extern PCmdActiveThreadDumpResDefaultTypeInternal _PCmdActiveThreadDumpRes_default_instance_;
class PCmdActiveThreadLightDump;
class PCmdActiveThreadLightDumpDefaultTypeInternal;
extern PCmdActiveThreadLightDumpDefaultTypeInternal _PCmdActiveThreadLightDump_default_instance_;
class PCmdActiveThreadLightDumpRes;
class PCmdActiveThreadLightDumpResDefaultTypeInternal;
extern PCmdActiveThreadLightDumpResDefaultTypeInternal _PCmdActiveThreadLightDumpRes_default_instance_;
class PCmdEcho;
class PCmdEchoDefaultTypeInternal;
extern PCmdEchoDefaultTypeInternal _PCmdEcho_default_instance_;
class PCmdEchoResponse;
class PCmdEchoResponseDefaultTypeInternal;
extern PCmdEchoResponseDefaultTypeInternal _PCmdEchoResponse_default_instance_;
class PCmdMessage;
class PCmdMessageDefaultTypeInternal;
extern PCmdMessageDefaultTypeInternal _PCmdMessage_default_instance_;
class PCmdRequest;
class PCmdRequestDefaultTypeInternal;
extern PCmdRequestDefaultTypeInternal _PCmdRequest_default_instance_;
class PCmdResponse;
class PCmdResponseDefaultTypeInternal;
extern PCmdResponseDefaultTypeInternal _PCmdResponse_default_instance_;
class PCmdServiceHandshake;
class PCmdServiceHandshakeDefaultTypeInternal;
extern PCmdServiceHandshakeDefaultTypeInternal _PCmdServiceHandshake_default_instance_;
class PCmdStreamResponse;
class PCmdStreamResponseDefaultTypeInternal;
extern PCmdStreamResponseDefaultTypeInternal _PCmdStreamResponse_default_instance_;
}  // namespace v1
namespace google {
namespace protobuf {
template<> ::v1::PCmdActiveThreadCount* Arena::CreateMaybeMessage<::v1::PCmdActiveThreadCount>(Arena*);
template<> ::v1::PCmdActiveThreadCountRes* Arena::CreateMaybeMessage<::v1::PCmdActiveThreadCountRes>(Arena*);
template<> ::v1::PCmdActiveThreadDump* Arena::CreateMaybeMessage<::v1::PCmdActiveThreadDump>(Arena*);
template<> ::v1::PCmdActiveThreadDumpRes* Arena::CreateMaybeMessage<::v1::PCmdActiveThreadDumpRes>(Arena*);
template<> ::v1::PCmdActiveThreadLightDump* Arena::CreateMaybeMessage<::v1::PCmdActiveThreadLightDump>(Arena*);
template<> ::v1::PCmdActiveThreadLightDumpRes* Arena::CreateMaybeMessage<::v1::PCmdActiveThreadLightDumpRes>(Arena*);
template<> ::v1::PCmdEcho* Arena::CreateMaybeMessage<::v1::PCmdEcho>(Arena*);
template<> ::v1::PCmdEchoResponse* Arena::CreateMaybeMessage<::v1::PCmdEchoResponse>(Arena*);
template<> ::v1::PCmdMessage* Arena::CreateMaybeMessage<::v1::PCmdMessage>(Arena*);
template<> ::v1::PCmdRequest* Arena::CreateMaybeMessage<::v1::PCmdRequest>(Arena*);
template<> ::v1::PCmdResponse* Arena::CreateMaybeMessage<::v1::PCmdResponse>(Arena*);
template<> ::v1::PCmdServiceHandshake* Arena::CreateMaybeMessage<::v1::PCmdServiceHandshake>(Arena*);
template<> ::v1::PCmdStreamResponse* Arena::CreateMaybeMessage<::v1::PCmdStreamResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace v1 {

enum PCommandType {
  NONE = 0,
  PING = 100,
  PONG = 101,
  ECHO = 710,
  ACTIVE_THREAD_COUNT = 730,
  ACTIVE_THREAD_DUMP = 740,
  ACTIVE_THREAD_LIGHT_DUMP = 750,
  PCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  PCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool PCommandType_IsValid(int value);
const PCommandType PCommandType_MIN = NONE;
const PCommandType PCommandType_MAX = ACTIVE_THREAD_LIGHT_DUMP;
const int PCommandType_ARRAYSIZE = PCommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PCommandType_descriptor();
inline const ::std::string& PCommandType_Name(PCommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PCommandType_descriptor(), value);
}
inline bool PCommandType_Parse(
    const ::std::string& name, PCommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PCommandType>(
    PCommandType_descriptor(), name, value);
}
// ===================================================================

class PCmdMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdMessage) */ {
 public:
  PCmdMessage();
  virtual ~PCmdMessage();

  PCmdMessage(const PCmdMessage& from);

  inline PCmdMessage& operator=(const PCmdMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdMessage(PCmdMessage&& from) noexcept
    : PCmdMessage() {
    *this = ::std::move(from);
  }

  inline PCmdMessage& operator=(PCmdMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdMessage& default_instance();

  enum MessageCase {
    kHandshakeMessage = 1,
    kFailMessage = 2,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdMessage* internal_default_instance() {
    return reinterpret_cast<const PCmdMessage*>(
               &_PCmdMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PCmdMessage* other);
  friend void swap(PCmdMessage& a, PCmdMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdMessage* New() const final {
    return CreateMaybeMessage<PCmdMessage>(nullptr);
  }

  PCmdMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdMessage& from);
  void MergeFrom(const PCmdMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .v1.PCmdServiceHandshake handshakeMessage = 1;
  bool has_handshakemessage() const;
  void clear_handshakemessage();
  static const int kHandshakeMessageFieldNumber = 1;
  const ::v1::PCmdServiceHandshake& handshakemessage() const;
  ::v1::PCmdServiceHandshake* release_handshakemessage();
  ::v1::PCmdServiceHandshake* mutable_handshakemessage();
  void set_allocated_handshakemessage(::v1::PCmdServiceHandshake* handshakemessage);

  // .v1.PCmdResponse failMessage = 2;
  bool has_failmessage() const;
  void clear_failmessage();
  static const int kFailMessageFieldNumber = 2;
  const ::v1::PCmdResponse& failmessage() const;
  ::v1::PCmdResponse* release_failmessage();
  ::v1::PCmdResponse* mutable_failmessage();
  void set_allocated_failmessage(::v1::PCmdResponse* failmessage);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:v1.PCmdMessage)
 private:
  class HasBitSetters;
  void set_has_handshakemessage();
  void set_has_failmessage();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessageUnion {
    MessageUnion() {}
    ::v1::PCmdServiceHandshake* handshakemessage_;
    ::v1::PCmdResponse* failmessage_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdServiceHandshake final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdServiceHandshake) */ {
 public:
  PCmdServiceHandshake();
  virtual ~PCmdServiceHandshake();

  PCmdServiceHandshake(const PCmdServiceHandshake& from);

  inline PCmdServiceHandshake& operator=(const PCmdServiceHandshake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdServiceHandshake(PCmdServiceHandshake&& from) noexcept
    : PCmdServiceHandshake() {
    *this = ::std::move(from);
  }

  inline PCmdServiceHandshake& operator=(PCmdServiceHandshake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdServiceHandshake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdServiceHandshake* internal_default_instance() {
    return reinterpret_cast<const PCmdServiceHandshake*>(
               &_PCmdServiceHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PCmdServiceHandshake* other);
  friend void swap(PCmdServiceHandshake& a, PCmdServiceHandshake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdServiceHandshake* New() const final {
    return CreateMaybeMessage<PCmdServiceHandshake>(nullptr);
  }

  PCmdServiceHandshake* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdServiceHandshake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdServiceHandshake& from);
  void MergeFrom(const PCmdServiceHandshake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdServiceHandshake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 supportCommandServiceKey = 1;
  int supportcommandservicekey_size() const;
  void clear_supportcommandservicekey();
  static const int kSupportCommandServiceKeyFieldNumber = 1;
  ::google::protobuf::int32 supportcommandservicekey(int index) const;
  void set_supportcommandservicekey(int index, ::google::protobuf::int32 value);
  void add_supportcommandservicekey(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      supportcommandservicekey() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_supportcommandservicekey();

  // @@protoc_insertion_point(class_scope:v1.PCmdServiceHandshake)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > supportcommandservicekey_;
  mutable std::atomic<int> _supportcommandservicekey_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdResponse) */ {
 public:
  PCmdResponse();
  virtual ~PCmdResponse();

  PCmdResponse(const PCmdResponse& from);

  inline PCmdResponse& operator=(const PCmdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdResponse(PCmdResponse&& from) noexcept
    : PCmdResponse() {
    *this = ::std::move(from);
  }

  inline PCmdResponse& operator=(PCmdResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdResponse* internal_default_instance() {
    return reinterpret_cast<const PCmdResponse*>(
               &_PCmdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PCmdResponse* other);
  friend void swap(PCmdResponse& a, PCmdResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdResponse* New() const final {
    return CreateMaybeMessage<PCmdResponse>(nullptr);
  }

  PCmdResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdResponse& from);
  void MergeFrom(const PCmdResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.StringValue message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::google::protobuf::StringValue& message() const;
  ::google::protobuf::StringValue* release_message();
  ::google::protobuf::StringValue* mutable_message();
  void set_allocated_message(::google::protobuf::StringValue* message);

  // int32 responseId = 1;
  void clear_responseid();
  static const int kResponseIdFieldNumber = 1;
  ::google::protobuf::int32 responseid() const;
  void set_responseid(::google::protobuf::int32 value);

  // int32 status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:v1.PCmdResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::StringValue* message_;
  ::google::protobuf::int32 responseid_;
  ::google::protobuf::int32 status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdStreamResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdStreamResponse) */ {
 public:
  PCmdStreamResponse();
  virtual ~PCmdStreamResponse();

  PCmdStreamResponse(const PCmdStreamResponse& from);

  inline PCmdStreamResponse& operator=(const PCmdStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdStreamResponse(PCmdStreamResponse&& from) noexcept
    : PCmdStreamResponse() {
    *this = ::std::move(from);
  }

  inline PCmdStreamResponse& operator=(PCmdStreamResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdStreamResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdStreamResponse* internal_default_instance() {
    return reinterpret_cast<const PCmdStreamResponse*>(
               &_PCmdStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PCmdStreamResponse* other);
  friend void swap(PCmdStreamResponse& a, PCmdStreamResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdStreamResponse* New() const final {
    return CreateMaybeMessage<PCmdStreamResponse>(nullptr);
  }

  PCmdStreamResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdStreamResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdStreamResponse& from);
  void MergeFrom(const PCmdStreamResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdStreamResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.StringValue message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::google::protobuf::StringValue& message() const;
  ::google::protobuf::StringValue* release_message();
  ::google::protobuf::StringValue* mutable_message();
  void set_allocated_message(::google::protobuf::StringValue* message);

  // int32 responseId = 1;
  void clear_responseid();
  static const int kResponseIdFieldNumber = 1;
  ::google::protobuf::int32 responseid() const;
  void set_responseid(::google::protobuf::int32 value);

  // int32 sequenceId = 2;
  void clear_sequenceid();
  static const int kSequenceIdFieldNumber = 2;
  ::google::protobuf::int32 sequenceid() const;
  void set_sequenceid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:v1.PCmdStreamResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::StringValue* message_;
  ::google::protobuf::int32 responseid_;
  ::google::protobuf::int32 sequenceid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdRequest) */ {
 public:
  PCmdRequest();
  virtual ~PCmdRequest();

  PCmdRequest(const PCmdRequest& from);

  inline PCmdRequest& operator=(const PCmdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdRequest(PCmdRequest&& from) noexcept
    : PCmdRequest() {
    *this = ::std::move(from);
  }

  inline PCmdRequest& operator=(PCmdRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdRequest& default_instance();

  enum CommandCase {
    kCommandEcho = 710,
    kCommandActiveThreadCount = 730,
    kCommandActiveThreadDump = 740,
    kCommandActiveThreadLightDump = 750,
    COMMAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdRequest* internal_default_instance() {
    return reinterpret_cast<const PCmdRequest*>(
               &_PCmdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PCmdRequest* other);
  friend void swap(PCmdRequest& a, PCmdRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdRequest* New() const final {
    return CreateMaybeMessage<PCmdRequest>(nullptr);
  }

  PCmdRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdRequest& from);
  void MergeFrom(const PCmdRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 requestId = 1;
  void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // .v1.PCmdEcho commandEcho = 710;
  bool has_commandecho() const;
  void clear_commandecho();
  static const int kCommandEchoFieldNumber = 710;
  const ::v1::PCmdEcho& commandecho() const;
  ::v1::PCmdEcho* release_commandecho();
  ::v1::PCmdEcho* mutable_commandecho();
  void set_allocated_commandecho(::v1::PCmdEcho* commandecho);

  // .v1.PCmdActiveThreadCount commandActiveThreadCount = 730;
  bool has_commandactivethreadcount() const;
  void clear_commandactivethreadcount();
  static const int kCommandActiveThreadCountFieldNumber = 730;
  const ::v1::PCmdActiveThreadCount& commandactivethreadcount() const;
  ::v1::PCmdActiveThreadCount* release_commandactivethreadcount();
  ::v1::PCmdActiveThreadCount* mutable_commandactivethreadcount();
  void set_allocated_commandactivethreadcount(::v1::PCmdActiveThreadCount* commandactivethreadcount);

  // .v1.PCmdActiveThreadDump commandActiveThreadDump = 740;
  bool has_commandactivethreaddump() const;
  void clear_commandactivethreaddump();
  static const int kCommandActiveThreadDumpFieldNumber = 740;
  const ::v1::PCmdActiveThreadDump& commandactivethreaddump() const;
  ::v1::PCmdActiveThreadDump* release_commandactivethreaddump();
  ::v1::PCmdActiveThreadDump* mutable_commandactivethreaddump();
  void set_allocated_commandactivethreaddump(::v1::PCmdActiveThreadDump* commandactivethreaddump);

  // .v1.PCmdActiveThreadLightDump commandActiveThreadLightDump = 750;
  bool has_commandactivethreadlightdump() const;
  void clear_commandactivethreadlightdump();
  static const int kCommandActiveThreadLightDumpFieldNumber = 750;
  const ::v1::PCmdActiveThreadLightDump& commandactivethreadlightdump() const;
  ::v1::PCmdActiveThreadLightDump* release_commandactivethreadlightdump();
  ::v1::PCmdActiveThreadLightDump* mutable_commandactivethreadlightdump();
  void set_allocated_commandactivethreadlightdump(::v1::PCmdActiveThreadLightDump* commandactivethreadlightdump);

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:v1.PCmdRequest)
 private:
  class HasBitSetters;
  void set_has_commandecho();
  void set_has_commandactivethreadcount();
  void set_has_commandactivethreaddump();
  void set_has_commandactivethreadlightdump();

  inline bool has_command() const;
  inline void clear_has_command();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 requestid_;
  union CommandUnion {
    CommandUnion() {}
    ::v1::PCmdEcho* commandecho_;
    ::v1::PCmdActiveThreadCount* commandactivethreadcount_;
    ::v1::PCmdActiveThreadDump* commandactivethreaddump_;
    ::v1::PCmdActiveThreadLightDump* commandactivethreadlightdump_;
  } command_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdEcho final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdEcho) */ {
 public:
  PCmdEcho();
  virtual ~PCmdEcho();

  PCmdEcho(const PCmdEcho& from);

  inline PCmdEcho& operator=(const PCmdEcho& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdEcho(PCmdEcho&& from) noexcept
    : PCmdEcho() {
    *this = ::std::move(from);
  }

  inline PCmdEcho& operator=(PCmdEcho&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdEcho& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdEcho* internal_default_instance() {
    return reinterpret_cast<const PCmdEcho*>(
               &_PCmdEcho_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(PCmdEcho* other);
  friend void swap(PCmdEcho& a, PCmdEcho& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdEcho* New() const final {
    return CreateMaybeMessage<PCmdEcho>(nullptr);
  }

  PCmdEcho* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdEcho>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdEcho& from);
  void MergeFrom(const PCmdEcho& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdEcho* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:v1.PCmdEcho)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdEchoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdEchoResponse) */ {
 public:
  PCmdEchoResponse();
  virtual ~PCmdEchoResponse();

  PCmdEchoResponse(const PCmdEchoResponse& from);

  inline PCmdEchoResponse& operator=(const PCmdEchoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdEchoResponse(PCmdEchoResponse&& from) noexcept
    : PCmdEchoResponse() {
    *this = ::std::move(from);
  }

  inline PCmdEchoResponse& operator=(PCmdEchoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdEchoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdEchoResponse* internal_default_instance() {
    return reinterpret_cast<const PCmdEchoResponse*>(
               &_PCmdEchoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PCmdEchoResponse* other);
  friend void swap(PCmdEchoResponse& a, PCmdEchoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdEchoResponse* New() const final {
    return CreateMaybeMessage<PCmdEchoResponse>(nullptr);
  }

  PCmdEchoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdEchoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdEchoResponse& from);
  void MergeFrom(const PCmdEchoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdEchoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .v1.PCmdResponse commonResponse = 1;
  bool has_commonresponse() const;
  void clear_commonresponse();
  static const int kCommonResponseFieldNumber = 1;
  const ::v1::PCmdResponse& commonresponse() const;
  ::v1::PCmdResponse* release_commonresponse();
  ::v1::PCmdResponse* mutable_commonresponse();
  void set_allocated_commonresponse(::v1::PCmdResponse* commonresponse);

  // @@protoc_insertion_point(class_scope:v1.PCmdEchoResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::v1::PCmdResponse* commonresponse_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdActiveThreadDump final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdActiveThreadDump) */ {
 public:
  PCmdActiveThreadDump();
  virtual ~PCmdActiveThreadDump();

  PCmdActiveThreadDump(const PCmdActiveThreadDump& from);

  inline PCmdActiveThreadDump& operator=(const PCmdActiveThreadDump& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdActiveThreadDump(PCmdActiveThreadDump&& from) noexcept
    : PCmdActiveThreadDump() {
    *this = ::std::move(from);
  }

  inline PCmdActiveThreadDump& operator=(PCmdActiveThreadDump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdActiveThreadDump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdActiveThreadDump* internal_default_instance() {
    return reinterpret_cast<const PCmdActiveThreadDump*>(
               &_PCmdActiveThreadDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PCmdActiveThreadDump* other);
  friend void swap(PCmdActiveThreadDump& a, PCmdActiveThreadDump& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdActiveThreadDump* New() const final {
    return CreateMaybeMessage<PCmdActiveThreadDump>(nullptr);
  }

  PCmdActiveThreadDump* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdActiveThreadDump>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdActiveThreadDump& from);
  void MergeFrom(const PCmdActiveThreadDump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdActiveThreadDump* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string threadName = 2;
  int threadname_size() const;
  void clear_threadname();
  static const int kThreadNameFieldNumber = 2;
  const ::std::string& threadname(int index) const;
  ::std::string* mutable_threadname(int index);
  void set_threadname(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_threadname(int index, ::std::string&& value);
  #endif
  void set_threadname(int index, const char* value);
  void set_threadname(int index, const char* value, size_t size);
  ::std::string* add_threadname();
  void add_threadname(const ::std::string& value);
  #if LANG_CXX11
  void add_threadname(::std::string&& value);
  #endif
  void add_threadname(const char* value);
  void add_threadname(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& threadname() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_threadname();

  // repeated int64 localTraceId = 3;
  int localtraceid_size() const;
  void clear_localtraceid();
  static const int kLocalTraceIdFieldNumber = 3;
  ::google::protobuf::int64 localtraceid(int index) const;
  void set_localtraceid(int index, ::google::protobuf::int64 value);
  void add_localtraceid(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      localtraceid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_localtraceid();

  // int32 limit = 1;
  void clear_limit();
  static const int kLimitFieldNumber = 1;
  ::google::protobuf::int32 limit() const;
  void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:v1.PCmdActiveThreadDump)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> threadname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > localtraceid_;
  mutable std::atomic<int> _localtraceid_cached_byte_size_;
  ::google::protobuf::int32 limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdActiveThreadDumpRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdActiveThreadDumpRes) */ {
 public:
  PCmdActiveThreadDumpRes();
  virtual ~PCmdActiveThreadDumpRes();

  PCmdActiveThreadDumpRes(const PCmdActiveThreadDumpRes& from);

  inline PCmdActiveThreadDumpRes& operator=(const PCmdActiveThreadDumpRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdActiveThreadDumpRes(PCmdActiveThreadDumpRes&& from) noexcept
    : PCmdActiveThreadDumpRes() {
    *this = ::std::move(from);
  }

  inline PCmdActiveThreadDumpRes& operator=(PCmdActiveThreadDumpRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdActiveThreadDumpRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdActiveThreadDumpRes* internal_default_instance() {
    return reinterpret_cast<const PCmdActiveThreadDumpRes*>(
               &_PCmdActiveThreadDumpRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(PCmdActiveThreadDumpRes* other);
  friend void swap(PCmdActiveThreadDumpRes& a, PCmdActiveThreadDumpRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdActiveThreadDumpRes* New() const final {
    return CreateMaybeMessage<PCmdActiveThreadDumpRes>(nullptr);
  }

  PCmdActiveThreadDumpRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdActiveThreadDumpRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdActiveThreadDumpRes& from);
  void MergeFrom(const PCmdActiveThreadDumpRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdActiveThreadDumpRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .v1.PActiveThreadDump threadDump = 2;
  int threaddump_size() const;
  void clear_threaddump();
  static const int kThreadDumpFieldNumber = 2;
  ::v1::PActiveThreadDump* mutable_threaddump(int index);
  ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadDump >*
      mutable_threaddump();
  const ::v1::PActiveThreadDump& threaddump(int index) const;
  ::v1::PActiveThreadDump* add_threaddump();
  const ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadDump >&
      threaddump() const;

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string subType = 4;
  void clear_subtype();
  static const int kSubTypeFieldNumber = 4;
  const ::std::string& subtype() const;
  void set_subtype(const ::std::string& value);
  #if LANG_CXX11
  void set_subtype(::std::string&& value);
  #endif
  void set_subtype(const char* value);
  void set_subtype(const char* value, size_t size);
  ::std::string* mutable_subtype();
  ::std::string* release_subtype();
  void set_allocated_subtype(::std::string* subtype);

  // string version = 5;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .v1.PCmdResponse commonResponse = 1;
  bool has_commonresponse() const;
  void clear_commonresponse();
  static const int kCommonResponseFieldNumber = 1;
  const ::v1::PCmdResponse& commonresponse() const;
  ::v1::PCmdResponse* release_commonresponse();
  ::v1::PCmdResponse* mutable_commonresponse();
  void set_allocated_commonresponse(::v1::PCmdResponse* commonresponse);

  // @@protoc_insertion_point(class_scope:v1.PCmdActiveThreadDumpRes)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadDump > threaddump_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr subtype_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::v1::PCmdResponse* commonresponse_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdActiveThreadLightDump final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdActiveThreadLightDump) */ {
 public:
  PCmdActiveThreadLightDump();
  virtual ~PCmdActiveThreadLightDump();

  PCmdActiveThreadLightDump(const PCmdActiveThreadLightDump& from);

  inline PCmdActiveThreadLightDump& operator=(const PCmdActiveThreadLightDump& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdActiveThreadLightDump(PCmdActiveThreadLightDump&& from) noexcept
    : PCmdActiveThreadLightDump() {
    *this = ::std::move(from);
  }

  inline PCmdActiveThreadLightDump& operator=(PCmdActiveThreadLightDump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdActiveThreadLightDump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdActiveThreadLightDump* internal_default_instance() {
    return reinterpret_cast<const PCmdActiveThreadLightDump*>(
               &_PCmdActiveThreadLightDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PCmdActiveThreadLightDump* other);
  friend void swap(PCmdActiveThreadLightDump& a, PCmdActiveThreadLightDump& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdActiveThreadLightDump* New() const final {
    return CreateMaybeMessage<PCmdActiveThreadLightDump>(nullptr);
  }

  PCmdActiveThreadLightDump* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdActiveThreadLightDump>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdActiveThreadLightDump& from);
  void MergeFrom(const PCmdActiveThreadLightDump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdActiveThreadLightDump* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string threadName = 2;
  int threadname_size() const;
  void clear_threadname();
  static const int kThreadNameFieldNumber = 2;
  const ::std::string& threadname(int index) const;
  ::std::string* mutable_threadname(int index);
  void set_threadname(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_threadname(int index, ::std::string&& value);
  #endif
  void set_threadname(int index, const char* value);
  void set_threadname(int index, const char* value, size_t size);
  ::std::string* add_threadname();
  void add_threadname(const ::std::string& value);
  #if LANG_CXX11
  void add_threadname(::std::string&& value);
  #endif
  void add_threadname(const char* value);
  void add_threadname(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& threadname() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_threadname();

  // repeated int64 localTraceId = 3;
  int localtraceid_size() const;
  void clear_localtraceid();
  static const int kLocalTraceIdFieldNumber = 3;
  ::google::protobuf::int64 localtraceid(int index) const;
  void set_localtraceid(int index, ::google::protobuf::int64 value);
  void add_localtraceid(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      localtraceid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_localtraceid();

  // int32 limit = 1;
  void clear_limit();
  static const int kLimitFieldNumber = 1;
  ::google::protobuf::int32 limit() const;
  void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:v1.PCmdActiveThreadLightDump)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> threadname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > localtraceid_;
  mutable std::atomic<int> _localtraceid_cached_byte_size_;
  ::google::protobuf::int32 limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdActiveThreadLightDumpRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdActiveThreadLightDumpRes) */ {
 public:
  PCmdActiveThreadLightDumpRes();
  virtual ~PCmdActiveThreadLightDumpRes();

  PCmdActiveThreadLightDumpRes(const PCmdActiveThreadLightDumpRes& from);

  inline PCmdActiveThreadLightDumpRes& operator=(const PCmdActiveThreadLightDumpRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdActiveThreadLightDumpRes(PCmdActiveThreadLightDumpRes&& from) noexcept
    : PCmdActiveThreadLightDumpRes() {
    *this = ::std::move(from);
  }

  inline PCmdActiveThreadLightDumpRes& operator=(PCmdActiveThreadLightDumpRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdActiveThreadLightDumpRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdActiveThreadLightDumpRes* internal_default_instance() {
    return reinterpret_cast<const PCmdActiveThreadLightDumpRes*>(
               &_PCmdActiveThreadLightDumpRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(PCmdActiveThreadLightDumpRes* other);
  friend void swap(PCmdActiveThreadLightDumpRes& a, PCmdActiveThreadLightDumpRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdActiveThreadLightDumpRes* New() const final {
    return CreateMaybeMessage<PCmdActiveThreadLightDumpRes>(nullptr);
  }

  PCmdActiveThreadLightDumpRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdActiveThreadLightDumpRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdActiveThreadLightDumpRes& from);
  void MergeFrom(const PCmdActiveThreadLightDumpRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdActiveThreadLightDumpRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .v1.PActiveThreadLightDump threadDump = 2;
  int threaddump_size() const;
  void clear_threaddump();
  static const int kThreadDumpFieldNumber = 2;
  ::v1::PActiveThreadLightDump* mutable_threaddump(int index);
  ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadLightDump >*
      mutable_threaddump();
  const ::v1::PActiveThreadLightDump& threaddump(int index) const;
  ::v1::PActiveThreadLightDump* add_threaddump();
  const ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadLightDump >&
      threaddump() const;

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string subType = 4;
  void clear_subtype();
  static const int kSubTypeFieldNumber = 4;
  const ::std::string& subtype() const;
  void set_subtype(const ::std::string& value);
  #if LANG_CXX11
  void set_subtype(::std::string&& value);
  #endif
  void set_subtype(const char* value);
  void set_subtype(const char* value, size_t size);
  ::std::string* mutable_subtype();
  ::std::string* release_subtype();
  void set_allocated_subtype(::std::string* subtype);

  // string version = 5;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .v1.PCmdResponse commonResponse = 1;
  bool has_commonresponse() const;
  void clear_commonresponse();
  static const int kCommonResponseFieldNumber = 1;
  const ::v1::PCmdResponse& commonresponse() const;
  ::v1::PCmdResponse* release_commonresponse();
  ::v1::PCmdResponse* mutable_commonresponse();
  void set_allocated_commonresponse(::v1::PCmdResponse* commonresponse);

  // @@protoc_insertion_point(class_scope:v1.PCmdActiveThreadLightDumpRes)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadLightDump > threaddump_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr subtype_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::v1::PCmdResponse* commonresponse_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdActiveThreadCount final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdActiveThreadCount) */ {
 public:
  PCmdActiveThreadCount();
  virtual ~PCmdActiveThreadCount();

  PCmdActiveThreadCount(const PCmdActiveThreadCount& from);

  inline PCmdActiveThreadCount& operator=(const PCmdActiveThreadCount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdActiveThreadCount(PCmdActiveThreadCount&& from) noexcept
    : PCmdActiveThreadCount() {
    *this = ::std::move(from);
  }

  inline PCmdActiveThreadCount& operator=(PCmdActiveThreadCount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdActiveThreadCount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdActiveThreadCount* internal_default_instance() {
    return reinterpret_cast<const PCmdActiveThreadCount*>(
               &_PCmdActiveThreadCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(PCmdActiveThreadCount* other);
  friend void swap(PCmdActiveThreadCount& a, PCmdActiveThreadCount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdActiveThreadCount* New() const final {
    return CreateMaybeMessage<PCmdActiveThreadCount>(nullptr);
  }

  PCmdActiveThreadCount* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdActiveThreadCount>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdActiveThreadCount& from);
  void MergeFrom(const PCmdActiveThreadCount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdActiveThreadCount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:v1.PCmdActiveThreadCount)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// -------------------------------------------------------------------

class PCmdActiveThreadCountRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.PCmdActiveThreadCountRes) */ {
 public:
  PCmdActiveThreadCountRes();
  virtual ~PCmdActiveThreadCountRes();

  PCmdActiveThreadCountRes(const PCmdActiveThreadCountRes& from);

  inline PCmdActiveThreadCountRes& operator=(const PCmdActiveThreadCountRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PCmdActiveThreadCountRes(PCmdActiveThreadCountRes&& from) noexcept
    : PCmdActiveThreadCountRes() {
    *this = ::std::move(from);
  }

  inline PCmdActiveThreadCountRes& operator=(PCmdActiveThreadCountRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PCmdActiveThreadCountRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PCmdActiveThreadCountRes* internal_default_instance() {
    return reinterpret_cast<const PCmdActiveThreadCountRes*>(
               &_PCmdActiveThreadCountRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PCmdActiveThreadCountRes* other);
  friend void swap(PCmdActiveThreadCountRes& a, PCmdActiveThreadCountRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PCmdActiveThreadCountRes* New() const final {
    return CreateMaybeMessage<PCmdActiveThreadCountRes>(nullptr);
  }

  PCmdActiveThreadCountRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PCmdActiveThreadCountRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PCmdActiveThreadCountRes& from);
  void MergeFrom(const PCmdActiveThreadCountRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCmdActiveThreadCountRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 activeThreadCount = 3;
  int activethreadcount_size() const;
  void clear_activethreadcount();
  static const int kActiveThreadCountFieldNumber = 3;
  ::google::protobuf::int32 activethreadcount(int index) const;
  void set_activethreadcount(int index, ::google::protobuf::int32 value);
  void add_activethreadcount(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      activethreadcount() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_activethreadcount();

  // .v1.PCmdStreamResponse commonStreamResponse = 1;
  bool has_commonstreamresponse() const;
  void clear_commonstreamresponse();
  static const int kCommonStreamResponseFieldNumber = 1;
  const ::v1::PCmdStreamResponse& commonstreamresponse() const;
  ::v1::PCmdStreamResponse* release_commonstreamresponse();
  ::v1::PCmdStreamResponse* mutable_commonstreamresponse();
  void set_allocated_commonstreamresponse(::v1::PCmdStreamResponse* commonstreamresponse);

  // int64 timeStamp = 4;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 histogramSchemaType = 2;
  void clear_histogramschematype();
  static const int kHistogramSchemaTypeFieldNumber = 2;
  ::google::protobuf::int32 histogramschematype() const;
  void set_histogramschematype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:v1.PCmdActiveThreadCountRes)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > activethreadcount_;
  mutable std::atomic<int> _activethreadcount_cached_byte_size_;
  ::v1::PCmdStreamResponse* commonstreamresponse_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 histogramschematype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cmd_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PCmdMessage

// .v1.PCmdServiceHandshake handshakeMessage = 1;
inline bool PCmdMessage::has_handshakemessage() const {
  return message_case() == kHandshakeMessage;
}
inline void PCmdMessage::set_has_handshakemessage() {
  _oneof_case_[0] = kHandshakeMessage;
}
inline void PCmdMessage::clear_handshakemessage() {
  if (has_handshakemessage()) {
    delete message_.handshakemessage_;
    clear_has_message();
  }
}
inline ::v1::PCmdServiceHandshake* PCmdMessage::release_handshakemessage() {
  // @@protoc_insertion_point(field_release:v1.PCmdMessage.handshakeMessage)
  if (has_handshakemessage()) {
    clear_has_message();
      ::v1::PCmdServiceHandshake* temp = message_.handshakemessage_;
    message_.handshakemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::PCmdServiceHandshake& PCmdMessage::handshakemessage() const {
  // @@protoc_insertion_point(field_get:v1.PCmdMessage.handshakeMessage)
  return has_handshakemessage()
      ? *message_.handshakemessage_
      : *reinterpret_cast< ::v1::PCmdServiceHandshake*>(&::v1::_PCmdServiceHandshake_default_instance_);
}
inline ::v1::PCmdServiceHandshake* PCmdMessage::mutable_handshakemessage() {
  if (!has_handshakemessage()) {
    clear_message();
    set_has_handshakemessage();
    message_.handshakemessage_ = CreateMaybeMessage< ::v1::PCmdServiceHandshake >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdMessage.handshakeMessage)
  return message_.handshakemessage_;
}

// .v1.PCmdResponse failMessage = 2;
inline bool PCmdMessage::has_failmessage() const {
  return message_case() == kFailMessage;
}
inline void PCmdMessage::set_has_failmessage() {
  _oneof_case_[0] = kFailMessage;
}
inline void PCmdMessage::clear_failmessage() {
  if (has_failmessage()) {
    delete message_.failmessage_;
    clear_has_message();
  }
}
inline ::v1::PCmdResponse* PCmdMessage::release_failmessage() {
  // @@protoc_insertion_point(field_release:v1.PCmdMessage.failMessage)
  if (has_failmessage()) {
    clear_has_message();
      ::v1::PCmdResponse* temp = message_.failmessage_;
    message_.failmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::PCmdResponse& PCmdMessage::failmessage() const {
  // @@protoc_insertion_point(field_get:v1.PCmdMessage.failMessage)
  return has_failmessage()
      ? *message_.failmessage_
      : *reinterpret_cast< ::v1::PCmdResponse*>(&::v1::_PCmdResponse_default_instance_);
}
inline ::v1::PCmdResponse* PCmdMessage::mutable_failmessage() {
  if (!has_failmessage()) {
    clear_message();
    set_has_failmessage();
    message_.failmessage_ = CreateMaybeMessage< ::v1::PCmdResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdMessage.failMessage)
  return message_.failmessage_;
}

inline bool PCmdMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void PCmdMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline PCmdMessage::MessageCase PCmdMessage::message_case() const {
  return PCmdMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PCmdServiceHandshake

// repeated int32 supportCommandServiceKey = 1;
inline int PCmdServiceHandshake::supportcommandservicekey_size() const {
  return supportcommandservicekey_.size();
}
inline void PCmdServiceHandshake::clear_supportcommandservicekey() {
  supportcommandservicekey_.Clear();
}
inline ::google::protobuf::int32 PCmdServiceHandshake::supportcommandservicekey(int index) const {
  // @@protoc_insertion_point(field_get:v1.PCmdServiceHandshake.supportCommandServiceKey)
  return supportcommandservicekey_.Get(index);
}
inline void PCmdServiceHandshake::set_supportcommandservicekey(int index, ::google::protobuf::int32 value) {
  supportcommandservicekey_.Set(index, value);
  // @@protoc_insertion_point(field_set:v1.PCmdServiceHandshake.supportCommandServiceKey)
}
inline void PCmdServiceHandshake::add_supportcommandservicekey(::google::protobuf::int32 value) {
  supportcommandservicekey_.Add(value);
  // @@protoc_insertion_point(field_add:v1.PCmdServiceHandshake.supportCommandServiceKey)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PCmdServiceHandshake::supportcommandservicekey() const {
  // @@protoc_insertion_point(field_list:v1.PCmdServiceHandshake.supportCommandServiceKey)
  return supportcommandservicekey_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PCmdServiceHandshake::mutable_supportcommandservicekey() {
  // @@protoc_insertion_point(field_mutable_list:v1.PCmdServiceHandshake.supportCommandServiceKey)
  return &supportcommandservicekey_;
}

// -------------------------------------------------------------------

// PCmdResponse

// int32 responseId = 1;
inline void PCmdResponse::clear_responseid() {
  responseid_ = 0;
}
inline ::google::protobuf::int32 PCmdResponse::responseid() const {
  // @@protoc_insertion_point(field_get:v1.PCmdResponse.responseId)
  return responseid_;
}
inline void PCmdResponse::set_responseid(::google::protobuf::int32 value) {
  
  responseid_ = value;
  // @@protoc_insertion_point(field_set:v1.PCmdResponse.responseId)
}

// int32 status = 2;
inline void PCmdResponse::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 PCmdResponse::status() const {
  // @@protoc_insertion_point(field_get:v1.PCmdResponse.status)
  return status_;
}
inline void PCmdResponse::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:v1.PCmdResponse.status)
}

// .google.protobuf.StringValue message = 3;
inline bool PCmdResponse::has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline const ::google::protobuf::StringValue& PCmdResponse::message() const {
  const ::google::protobuf::StringValue* p = message_;
  // @@protoc_insertion_point(field_get:v1.PCmdResponse.message)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* PCmdResponse::release_message() {
  // @@protoc_insertion_point(field_release:v1.PCmdResponse.message)
  
  ::google::protobuf::StringValue* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* PCmdResponse::mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdResponse.message)
  return message_;
}
inline void PCmdResponse::set_allocated_message(::google::protobuf::StringValue* message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(message_);
  }
  if (message) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(message)->GetArena();
    if (message_arena != submessage_arena) {
      message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdResponse.message)
}

// -------------------------------------------------------------------

// PCmdStreamResponse

// int32 responseId = 1;
inline void PCmdStreamResponse::clear_responseid() {
  responseid_ = 0;
}
inline ::google::protobuf::int32 PCmdStreamResponse::responseid() const {
  // @@protoc_insertion_point(field_get:v1.PCmdStreamResponse.responseId)
  return responseid_;
}
inline void PCmdStreamResponse::set_responseid(::google::protobuf::int32 value) {
  
  responseid_ = value;
  // @@protoc_insertion_point(field_set:v1.PCmdStreamResponse.responseId)
}

// int32 sequenceId = 2;
inline void PCmdStreamResponse::clear_sequenceid() {
  sequenceid_ = 0;
}
inline ::google::protobuf::int32 PCmdStreamResponse::sequenceid() const {
  // @@protoc_insertion_point(field_get:v1.PCmdStreamResponse.sequenceId)
  return sequenceid_;
}
inline void PCmdStreamResponse::set_sequenceid(::google::protobuf::int32 value) {
  
  sequenceid_ = value;
  // @@protoc_insertion_point(field_set:v1.PCmdStreamResponse.sequenceId)
}

// .google.protobuf.StringValue message = 3;
inline bool PCmdStreamResponse::has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline const ::google::protobuf::StringValue& PCmdStreamResponse::message() const {
  const ::google::protobuf::StringValue* p = message_;
  // @@protoc_insertion_point(field_get:v1.PCmdStreamResponse.message)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* PCmdStreamResponse::release_message() {
  // @@protoc_insertion_point(field_release:v1.PCmdStreamResponse.message)
  
  ::google::protobuf::StringValue* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* PCmdStreamResponse::mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdStreamResponse.message)
  return message_;
}
inline void PCmdStreamResponse::set_allocated_message(::google::protobuf::StringValue* message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(message_);
  }
  if (message) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(message)->GetArena();
    if (message_arena != submessage_arena) {
      message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdStreamResponse.message)
}

// -------------------------------------------------------------------

// PCmdRequest

// int32 requestId = 1;
inline void PCmdRequest::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 PCmdRequest::requestid() const {
  // @@protoc_insertion_point(field_get:v1.PCmdRequest.requestId)
  return requestid_;
}
inline void PCmdRequest::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:v1.PCmdRequest.requestId)
}

// .v1.PCmdEcho commandEcho = 710;
inline bool PCmdRequest::has_commandecho() const {
  return command_case() == kCommandEcho;
}
inline void PCmdRequest::set_has_commandecho() {
  _oneof_case_[0] = kCommandEcho;
}
inline void PCmdRequest::clear_commandecho() {
  if (has_commandecho()) {
    delete command_.commandecho_;
    clear_has_command();
  }
}
inline ::v1::PCmdEcho* PCmdRequest::release_commandecho() {
  // @@protoc_insertion_point(field_release:v1.PCmdRequest.commandEcho)
  if (has_commandecho()) {
    clear_has_command();
      ::v1::PCmdEcho* temp = command_.commandecho_;
    command_.commandecho_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::PCmdEcho& PCmdRequest::commandecho() const {
  // @@protoc_insertion_point(field_get:v1.PCmdRequest.commandEcho)
  return has_commandecho()
      ? *command_.commandecho_
      : *reinterpret_cast< ::v1::PCmdEcho*>(&::v1::_PCmdEcho_default_instance_);
}
inline ::v1::PCmdEcho* PCmdRequest::mutable_commandecho() {
  if (!has_commandecho()) {
    clear_command();
    set_has_commandecho();
    command_.commandecho_ = CreateMaybeMessage< ::v1::PCmdEcho >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdRequest.commandEcho)
  return command_.commandecho_;
}

// .v1.PCmdActiveThreadCount commandActiveThreadCount = 730;
inline bool PCmdRequest::has_commandactivethreadcount() const {
  return command_case() == kCommandActiveThreadCount;
}
inline void PCmdRequest::set_has_commandactivethreadcount() {
  _oneof_case_[0] = kCommandActiveThreadCount;
}
inline void PCmdRequest::clear_commandactivethreadcount() {
  if (has_commandactivethreadcount()) {
    delete command_.commandactivethreadcount_;
    clear_has_command();
  }
}
inline ::v1::PCmdActiveThreadCount* PCmdRequest::release_commandactivethreadcount() {
  // @@protoc_insertion_point(field_release:v1.PCmdRequest.commandActiveThreadCount)
  if (has_commandactivethreadcount()) {
    clear_has_command();
      ::v1::PCmdActiveThreadCount* temp = command_.commandactivethreadcount_;
    command_.commandactivethreadcount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::PCmdActiveThreadCount& PCmdRequest::commandactivethreadcount() const {
  // @@protoc_insertion_point(field_get:v1.PCmdRequest.commandActiveThreadCount)
  return has_commandactivethreadcount()
      ? *command_.commandactivethreadcount_
      : *reinterpret_cast< ::v1::PCmdActiveThreadCount*>(&::v1::_PCmdActiveThreadCount_default_instance_);
}
inline ::v1::PCmdActiveThreadCount* PCmdRequest::mutable_commandactivethreadcount() {
  if (!has_commandactivethreadcount()) {
    clear_command();
    set_has_commandactivethreadcount();
    command_.commandactivethreadcount_ = CreateMaybeMessage< ::v1::PCmdActiveThreadCount >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdRequest.commandActiveThreadCount)
  return command_.commandactivethreadcount_;
}

// .v1.PCmdActiveThreadDump commandActiveThreadDump = 740;
inline bool PCmdRequest::has_commandactivethreaddump() const {
  return command_case() == kCommandActiveThreadDump;
}
inline void PCmdRequest::set_has_commandactivethreaddump() {
  _oneof_case_[0] = kCommandActiveThreadDump;
}
inline void PCmdRequest::clear_commandactivethreaddump() {
  if (has_commandactivethreaddump()) {
    delete command_.commandactivethreaddump_;
    clear_has_command();
  }
}
inline ::v1::PCmdActiveThreadDump* PCmdRequest::release_commandactivethreaddump() {
  // @@protoc_insertion_point(field_release:v1.PCmdRequest.commandActiveThreadDump)
  if (has_commandactivethreaddump()) {
    clear_has_command();
      ::v1::PCmdActiveThreadDump* temp = command_.commandactivethreaddump_;
    command_.commandactivethreaddump_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::PCmdActiveThreadDump& PCmdRequest::commandactivethreaddump() const {
  // @@protoc_insertion_point(field_get:v1.PCmdRequest.commandActiveThreadDump)
  return has_commandactivethreaddump()
      ? *command_.commandactivethreaddump_
      : *reinterpret_cast< ::v1::PCmdActiveThreadDump*>(&::v1::_PCmdActiveThreadDump_default_instance_);
}
inline ::v1::PCmdActiveThreadDump* PCmdRequest::mutable_commandactivethreaddump() {
  if (!has_commandactivethreaddump()) {
    clear_command();
    set_has_commandactivethreaddump();
    command_.commandactivethreaddump_ = CreateMaybeMessage< ::v1::PCmdActiveThreadDump >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdRequest.commandActiveThreadDump)
  return command_.commandactivethreaddump_;
}

// .v1.PCmdActiveThreadLightDump commandActiveThreadLightDump = 750;
inline bool PCmdRequest::has_commandactivethreadlightdump() const {
  return command_case() == kCommandActiveThreadLightDump;
}
inline void PCmdRequest::set_has_commandactivethreadlightdump() {
  _oneof_case_[0] = kCommandActiveThreadLightDump;
}
inline void PCmdRequest::clear_commandactivethreadlightdump() {
  if (has_commandactivethreadlightdump()) {
    delete command_.commandactivethreadlightdump_;
    clear_has_command();
  }
}
inline ::v1::PCmdActiveThreadLightDump* PCmdRequest::release_commandactivethreadlightdump() {
  // @@protoc_insertion_point(field_release:v1.PCmdRequest.commandActiveThreadLightDump)
  if (has_commandactivethreadlightdump()) {
    clear_has_command();
      ::v1::PCmdActiveThreadLightDump* temp = command_.commandactivethreadlightdump_;
    command_.commandactivethreadlightdump_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::PCmdActiveThreadLightDump& PCmdRequest::commandactivethreadlightdump() const {
  // @@protoc_insertion_point(field_get:v1.PCmdRequest.commandActiveThreadLightDump)
  return has_commandactivethreadlightdump()
      ? *command_.commandactivethreadlightdump_
      : *reinterpret_cast< ::v1::PCmdActiveThreadLightDump*>(&::v1::_PCmdActiveThreadLightDump_default_instance_);
}
inline ::v1::PCmdActiveThreadLightDump* PCmdRequest::mutable_commandactivethreadlightdump() {
  if (!has_commandactivethreadlightdump()) {
    clear_command();
    set_has_commandactivethreadlightdump();
    command_.commandactivethreadlightdump_ = CreateMaybeMessage< ::v1::PCmdActiveThreadLightDump >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdRequest.commandActiveThreadLightDump)
  return command_.commandactivethreadlightdump_;
}

inline bool PCmdRequest::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void PCmdRequest::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline PCmdRequest::CommandCase PCmdRequest::command_case() const {
  return PCmdRequest::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PCmdEcho

// string message = 1;
inline void PCmdEcho::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PCmdEcho::message() const {
  // @@protoc_insertion_point(field_get:v1.PCmdEcho.message)
  return message_.GetNoArena();
}
inline void PCmdEcho::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PCmdEcho.message)
}
#if LANG_CXX11
inline void PCmdEcho::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PCmdEcho.message)
}
#endif
inline void PCmdEcho::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PCmdEcho.message)
}
inline void PCmdEcho::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdEcho.message)
}
inline ::std::string* PCmdEcho::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:v1.PCmdEcho.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PCmdEcho::release_message() {
  // @@protoc_insertion_point(field_release:v1.PCmdEcho.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PCmdEcho::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdEcho.message)
}

// -------------------------------------------------------------------

// PCmdEchoResponse

// .v1.PCmdResponse commonResponse = 1;
inline bool PCmdEchoResponse::has_commonresponse() const {
  return this != internal_default_instance() && commonresponse_ != nullptr;
}
inline void PCmdEchoResponse::clear_commonresponse() {
  if (GetArenaNoVirtual() == nullptr && commonresponse_ != nullptr) {
    delete commonresponse_;
  }
  commonresponse_ = nullptr;
}
inline const ::v1::PCmdResponse& PCmdEchoResponse::commonresponse() const {
  const ::v1::PCmdResponse* p = commonresponse_;
  // @@protoc_insertion_point(field_get:v1.PCmdEchoResponse.commonResponse)
  return p != nullptr ? *p : *reinterpret_cast<const ::v1::PCmdResponse*>(
      &::v1::_PCmdResponse_default_instance_);
}
inline ::v1::PCmdResponse* PCmdEchoResponse::release_commonresponse() {
  // @@protoc_insertion_point(field_release:v1.PCmdEchoResponse.commonResponse)
  
  ::v1::PCmdResponse* temp = commonresponse_;
  commonresponse_ = nullptr;
  return temp;
}
inline ::v1::PCmdResponse* PCmdEchoResponse::mutable_commonresponse() {
  
  if (commonresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::PCmdResponse>(GetArenaNoVirtual());
    commonresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdEchoResponse.commonResponse)
  return commonresponse_;
}
inline void PCmdEchoResponse::set_allocated_commonresponse(::v1::PCmdResponse* commonresponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete commonresponse_;
  }
  if (commonresponse) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      commonresponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, commonresponse, submessage_arena);
    }
    
  } else {
    
  }
  commonresponse_ = commonresponse;
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdEchoResponse.commonResponse)
}

// string message = 2;
inline void PCmdEchoResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PCmdEchoResponse::message() const {
  // @@protoc_insertion_point(field_get:v1.PCmdEchoResponse.message)
  return message_.GetNoArena();
}
inline void PCmdEchoResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PCmdEchoResponse.message)
}
#if LANG_CXX11
inline void PCmdEchoResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PCmdEchoResponse.message)
}
#endif
inline void PCmdEchoResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PCmdEchoResponse.message)
}
inline void PCmdEchoResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdEchoResponse.message)
}
inline ::std::string* PCmdEchoResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:v1.PCmdEchoResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PCmdEchoResponse::release_message() {
  // @@protoc_insertion_point(field_release:v1.PCmdEchoResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PCmdEchoResponse::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdEchoResponse.message)
}

// -------------------------------------------------------------------

// PCmdActiveThreadDump

// int32 limit = 1;
inline void PCmdActiveThreadDump::clear_limit() {
  limit_ = 0;
}
inline ::google::protobuf::int32 PCmdActiveThreadDump::limit() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadDump.limit)
  return limit_;
}
inline void PCmdActiveThreadDump::set_limit(::google::protobuf::int32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadDump.limit)
}

// repeated string threadName = 2;
inline int PCmdActiveThreadDump::threadname_size() const {
  return threadname_.size();
}
inline void PCmdActiveThreadDump::clear_threadname() {
  threadname_.Clear();
}
inline const ::std::string& PCmdActiveThreadDump::threadname(int index) const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadDump.threadName)
  return threadname_.Get(index);
}
inline ::std::string* PCmdActiveThreadDump::mutable_threadname(int index) {
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadDump.threadName)
  return threadname_.Mutable(index);
}
inline void PCmdActiveThreadDump::set_threadname(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadDump.threadName)
  threadname_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PCmdActiveThreadDump::set_threadname(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadDump.threadName)
  threadname_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PCmdActiveThreadDump::set_threadname(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  threadname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v1.PCmdActiveThreadDump.threadName)
}
inline void PCmdActiveThreadDump::set_threadname(int index, const char* value, size_t size) {
  threadname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdActiveThreadDump.threadName)
}
inline ::std::string* PCmdActiveThreadDump::add_threadname() {
  // @@protoc_insertion_point(field_add_mutable:v1.PCmdActiveThreadDump.threadName)
  return threadname_.Add();
}
inline void PCmdActiveThreadDump::add_threadname(const ::std::string& value) {
  threadname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v1.PCmdActiveThreadDump.threadName)
}
#if LANG_CXX11
inline void PCmdActiveThreadDump::add_threadname(::std::string&& value) {
  threadname_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v1.PCmdActiveThreadDump.threadName)
}
#endif
inline void PCmdActiveThreadDump::add_threadname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  threadname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v1.PCmdActiveThreadDump.threadName)
}
inline void PCmdActiveThreadDump::add_threadname(const char* value, size_t size) {
  threadname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v1.PCmdActiveThreadDump.threadName)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PCmdActiveThreadDump::threadname() const {
  // @@protoc_insertion_point(field_list:v1.PCmdActiveThreadDump.threadName)
  return threadname_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
PCmdActiveThreadDump::mutable_threadname() {
  // @@protoc_insertion_point(field_mutable_list:v1.PCmdActiveThreadDump.threadName)
  return &threadname_;
}

// repeated int64 localTraceId = 3;
inline int PCmdActiveThreadDump::localtraceid_size() const {
  return localtraceid_.size();
}
inline void PCmdActiveThreadDump::clear_localtraceid() {
  localtraceid_.Clear();
}
inline ::google::protobuf::int64 PCmdActiveThreadDump::localtraceid(int index) const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadDump.localTraceId)
  return localtraceid_.Get(index);
}
inline void PCmdActiveThreadDump::set_localtraceid(int index, ::google::protobuf::int64 value) {
  localtraceid_.Set(index, value);
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadDump.localTraceId)
}
inline void PCmdActiveThreadDump::add_localtraceid(::google::protobuf::int64 value) {
  localtraceid_.Add(value);
  // @@protoc_insertion_point(field_add:v1.PCmdActiveThreadDump.localTraceId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PCmdActiveThreadDump::localtraceid() const {
  // @@protoc_insertion_point(field_list:v1.PCmdActiveThreadDump.localTraceId)
  return localtraceid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PCmdActiveThreadDump::mutable_localtraceid() {
  // @@protoc_insertion_point(field_mutable_list:v1.PCmdActiveThreadDump.localTraceId)
  return &localtraceid_;
}

// -------------------------------------------------------------------

// PCmdActiveThreadDumpRes

// .v1.PCmdResponse commonResponse = 1;
inline bool PCmdActiveThreadDumpRes::has_commonresponse() const {
  return this != internal_default_instance() && commonresponse_ != nullptr;
}
inline void PCmdActiveThreadDumpRes::clear_commonresponse() {
  if (GetArenaNoVirtual() == nullptr && commonresponse_ != nullptr) {
    delete commonresponse_;
  }
  commonresponse_ = nullptr;
}
inline const ::v1::PCmdResponse& PCmdActiveThreadDumpRes::commonresponse() const {
  const ::v1::PCmdResponse* p = commonresponse_;
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadDumpRes.commonResponse)
  return p != nullptr ? *p : *reinterpret_cast<const ::v1::PCmdResponse*>(
      &::v1::_PCmdResponse_default_instance_);
}
inline ::v1::PCmdResponse* PCmdActiveThreadDumpRes::release_commonresponse() {
  // @@protoc_insertion_point(field_release:v1.PCmdActiveThreadDumpRes.commonResponse)
  
  ::v1::PCmdResponse* temp = commonresponse_;
  commonresponse_ = nullptr;
  return temp;
}
inline ::v1::PCmdResponse* PCmdActiveThreadDumpRes::mutable_commonresponse() {
  
  if (commonresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::PCmdResponse>(GetArenaNoVirtual());
    commonresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadDumpRes.commonResponse)
  return commonresponse_;
}
inline void PCmdActiveThreadDumpRes::set_allocated_commonresponse(::v1::PCmdResponse* commonresponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete commonresponse_;
  }
  if (commonresponse) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      commonresponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, commonresponse, submessage_arena);
    }
    
  } else {
    
  }
  commonresponse_ = commonresponse;
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdActiveThreadDumpRes.commonResponse)
}

// repeated .v1.PActiveThreadDump threadDump = 2;
inline int PCmdActiveThreadDumpRes::threaddump_size() const {
  return threaddump_.size();
}
inline ::v1::PActiveThreadDump* PCmdActiveThreadDumpRes::mutable_threaddump(int index) {
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadDumpRes.threadDump)
  return threaddump_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadDump >*
PCmdActiveThreadDumpRes::mutable_threaddump() {
  // @@protoc_insertion_point(field_mutable_list:v1.PCmdActiveThreadDumpRes.threadDump)
  return &threaddump_;
}
inline const ::v1::PActiveThreadDump& PCmdActiveThreadDumpRes::threaddump(int index) const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadDumpRes.threadDump)
  return threaddump_.Get(index);
}
inline ::v1::PActiveThreadDump* PCmdActiveThreadDumpRes::add_threaddump() {
  // @@protoc_insertion_point(field_add:v1.PCmdActiveThreadDumpRes.threadDump)
  return threaddump_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadDump >&
PCmdActiveThreadDumpRes::threaddump() const {
  // @@protoc_insertion_point(field_list:v1.PCmdActiveThreadDumpRes.threadDump)
  return threaddump_;
}

// string type = 3;
inline void PCmdActiveThreadDumpRes::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PCmdActiveThreadDumpRes::type() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadDumpRes.type)
  return type_.GetNoArena();
}
inline void PCmdActiveThreadDumpRes::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadDumpRes.type)
}
#if LANG_CXX11
inline void PCmdActiveThreadDumpRes::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PCmdActiveThreadDumpRes.type)
}
#endif
inline void PCmdActiveThreadDumpRes::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PCmdActiveThreadDumpRes.type)
}
inline void PCmdActiveThreadDumpRes::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdActiveThreadDumpRes.type)
}
inline ::std::string* PCmdActiveThreadDumpRes::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadDumpRes.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PCmdActiveThreadDumpRes::release_type() {
  // @@protoc_insertion_point(field_release:v1.PCmdActiveThreadDumpRes.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PCmdActiveThreadDumpRes::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdActiveThreadDumpRes.type)
}

// string subType = 4;
inline void PCmdActiveThreadDumpRes::clear_subtype() {
  subtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PCmdActiveThreadDumpRes::subtype() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadDumpRes.subType)
  return subtype_.GetNoArena();
}
inline void PCmdActiveThreadDumpRes::set_subtype(const ::std::string& value) {
  
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadDumpRes.subType)
}
#if LANG_CXX11
inline void PCmdActiveThreadDumpRes::set_subtype(::std::string&& value) {
  
  subtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PCmdActiveThreadDumpRes.subType)
}
#endif
inline void PCmdActiveThreadDumpRes::set_subtype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PCmdActiveThreadDumpRes.subType)
}
inline void PCmdActiveThreadDumpRes::set_subtype(const char* value, size_t size) {
  
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdActiveThreadDumpRes.subType)
}
inline ::std::string* PCmdActiveThreadDumpRes::mutable_subtype() {
  
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadDumpRes.subType)
  return subtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PCmdActiveThreadDumpRes::release_subtype() {
  // @@protoc_insertion_point(field_release:v1.PCmdActiveThreadDumpRes.subType)
  
  return subtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PCmdActiveThreadDumpRes::set_allocated_subtype(::std::string* subtype) {
  if (subtype != nullptr) {
    
  } else {
    
  }
  subtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subtype);
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdActiveThreadDumpRes.subType)
}

// string version = 5;
inline void PCmdActiveThreadDumpRes::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PCmdActiveThreadDumpRes::version() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadDumpRes.version)
  return version_.GetNoArena();
}
inline void PCmdActiveThreadDumpRes::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadDumpRes.version)
}
#if LANG_CXX11
inline void PCmdActiveThreadDumpRes::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PCmdActiveThreadDumpRes.version)
}
#endif
inline void PCmdActiveThreadDumpRes::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PCmdActiveThreadDumpRes.version)
}
inline void PCmdActiveThreadDumpRes::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdActiveThreadDumpRes.version)
}
inline ::std::string* PCmdActiveThreadDumpRes::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadDumpRes.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PCmdActiveThreadDumpRes::release_version() {
  // @@protoc_insertion_point(field_release:v1.PCmdActiveThreadDumpRes.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PCmdActiveThreadDumpRes::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdActiveThreadDumpRes.version)
}

// -------------------------------------------------------------------

// PCmdActiveThreadLightDump

// int32 limit = 1;
inline void PCmdActiveThreadLightDump::clear_limit() {
  limit_ = 0;
}
inline ::google::protobuf::int32 PCmdActiveThreadLightDump::limit() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadLightDump.limit)
  return limit_;
}
inline void PCmdActiveThreadLightDump::set_limit(::google::protobuf::int32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadLightDump.limit)
}

// repeated string threadName = 2;
inline int PCmdActiveThreadLightDump::threadname_size() const {
  return threadname_.size();
}
inline void PCmdActiveThreadLightDump::clear_threadname() {
  threadname_.Clear();
}
inline const ::std::string& PCmdActiveThreadLightDump::threadname(int index) const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadLightDump.threadName)
  return threadname_.Get(index);
}
inline ::std::string* PCmdActiveThreadLightDump::mutable_threadname(int index) {
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadLightDump.threadName)
  return threadname_.Mutable(index);
}
inline void PCmdActiveThreadLightDump::set_threadname(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadLightDump.threadName)
  threadname_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PCmdActiveThreadLightDump::set_threadname(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadLightDump.threadName)
  threadname_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PCmdActiveThreadLightDump::set_threadname(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  threadname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v1.PCmdActiveThreadLightDump.threadName)
}
inline void PCmdActiveThreadLightDump::set_threadname(int index, const char* value, size_t size) {
  threadname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdActiveThreadLightDump.threadName)
}
inline ::std::string* PCmdActiveThreadLightDump::add_threadname() {
  // @@protoc_insertion_point(field_add_mutable:v1.PCmdActiveThreadLightDump.threadName)
  return threadname_.Add();
}
inline void PCmdActiveThreadLightDump::add_threadname(const ::std::string& value) {
  threadname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v1.PCmdActiveThreadLightDump.threadName)
}
#if LANG_CXX11
inline void PCmdActiveThreadLightDump::add_threadname(::std::string&& value) {
  threadname_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v1.PCmdActiveThreadLightDump.threadName)
}
#endif
inline void PCmdActiveThreadLightDump::add_threadname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  threadname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v1.PCmdActiveThreadLightDump.threadName)
}
inline void PCmdActiveThreadLightDump::add_threadname(const char* value, size_t size) {
  threadname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v1.PCmdActiveThreadLightDump.threadName)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PCmdActiveThreadLightDump::threadname() const {
  // @@protoc_insertion_point(field_list:v1.PCmdActiveThreadLightDump.threadName)
  return threadname_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
PCmdActiveThreadLightDump::mutable_threadname() {
  // @@protoc_insertion_point(field_mutable_list:v1.PCmdActiveThreadLightDump.threadName)
  return &threadname_;
}

// repeated int64 localTraceId = 3;
inline int PCmdActiveThreadLightDump::localtraceid_size() const {
  return localtraceid_.size();
}
inline void PCmdActiveThreadLightDump::clear_localtraceid() {
  localtraceid_.Clear();
}
inline ::google::protobuf::int64 PCmdActiveThreadLightDump::localtraceid(int index) const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadLightDump.localTraceId)
  return localtraceid_.Get(index);
}
inline void PCmdActiveThreadLightDump::set_localtraceid(int index, ::google::protobuf::int64 value) {
  localtraceid_.Set(index, value);
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadLightDump.localTraceId)
}
inline void PCmdActiveThreadLightDump::add_localtraceid(::google::protobuf::int64 value) {
  localtraceid_.Add(value);
  // @@protoc_insertion_point(field_add:v1.PCmdActiveThreadLightDump.localTraceId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PCmdActiveThreadLightDump::localtraceid() const {
  // @@protoc_insertion_point(field_list:v1.PCmdActiveThreadLightDump.localTraceId)
  return localtraceid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PCmdActiveThreadLightDump::mutable_localtraceid() {
  // @@protoc_insertion_point(field_mutable_list:v1.PCmdActiveThreadLightDump.localTraceId)
  return &localtraceid_;
}

// -------------------------------------------------------------------

// PCmdActiveThreadLightDumpRes

// .v1.PCmdResponse commonResponse = 1;
inline bool PCmdActiveThreadLightDumpRes::has_commonresponse() const {
  return this != internal_default_instance() && commonresponse_ != nullptr;
}
inline void PCmdActiveThreadLightDumpRes::clear_commonresponse() {
  if (GetArenaNoVirtual() == nullptr && commonresponse_ != nullptr) {
    delete commonresponse_;
  }
  commonresponse_ = nullptr;
}
inline const ::v1::PCmdResponse& PCmdActiveThreadLightDumpRes::commonresponse() const {
  const ::v1::PCmdResponse* p = commonresponse_;
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadLightDumpRes.commonResponse)
  return p != nullptr ? *p : *reinterpret_cast<const ::v1::PCmdResponse*>(
      &::v1::_PCmdResponse_default_instance_);
}
inline ::v1::PCmdResponse* PCmdActiveThreadLightDumpRes::release_commonresponse() {
  // @@protoc_insertion_point(field_release:v1.PCmdActiveThreadLightDumpRes.commonResponse)
  
  ::v1::PCmdResponse* temp = commonresponse_;
  commonresponse_ = nullptr;
  return temp;
}
inline ::v1::PCmdResponse* PCmdActiveThreadLightDumpRes::mutable_commonresponse() {
  
  if (commonresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::PCmdResponse>(GetArenaNoVirtual());
    commonresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadLightDumpRes.commonResponse)
  return commonresponse_;
}
inline void PCmdActiveThreadLightDumpRes::set_allocated_commonresponse(::v1::PCmdResponse* commonresponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete commonresponse_;
  }
  if (commonresponse) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      commonresponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, commonresponse, submessage_arena);
    }
    
  } else {
    
  }
  commonresponse_ = commonresponse;
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdActiveThreadLightDumpRes.commonResponse)
}

// repeated .v1.PActiveThreadLightDump threadDump = 2;
inline int PCmdActiveThreadLightDumpRes::threaddump_size() const {
  return threaddump_.size();
}
inline ::v1::PActiveThreadLightDump* PCmdActiveThreadLightDumpRes::mutable_threaddump(int index) {
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadLightDumpRes.threadDump)
  return threaddump_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadLightDump >*
PCmdActiveThreadLightDumpRes::mutable_threaddump() {
  // @@protoc_insertion_point(field_mutable_list:v1.PCmdActiveThreadLightDumpRes.threadDump)
  return &threaddump_;
}
inline const ::v1::PActiveThreadLightDump& PCmdActiveThreadLightDumpRes::threaddump(int index) const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadLightDumpRes.threadDump)
  return threaddump_.Get(index);
}
inline ::v1::PActiveThreadLightDump* PCmdActiveThreadLightDumpRes::add_threaddump() {
  // @@protoc_insertion_point(field_add:v1.PCmdActiveThreadLightDumpRes.threadDump)
  return threaddump_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::v1::PActiveThreadLightDump >&
PCmdActiveThreadLightDumpRes::threaddump() const {
  // @@protoc_insertion_point(field_list:v1.PCmdActiveThreadLightDumpRes.threadDump)
  return threaddump_;
}

// string type = 3;
inline void PCmdActiveThreadLightDumpRes::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PCmdActiveThreadLightDumpRes::type() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadLightDumpRes.type)
  return type_.GetNoArena();
}
inline void PCmdActiveThreadLightDumpRes::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadLightDumpRes.type)
}
#if LANG_CXX11
inline void PCmdActiveThreadLightDumpRes::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PCmdActiveThreadLightDumpRes.type)
}
#endif
inline void PCmdActiveThreadLightDumpRes::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PCmdActiveThreadLightDumpRes.type)
}
inline void PCmdActiveThreadLightDumpRes::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdActiveThreadLightDumpRes.type)
}
inline ::std::string* PCmdActiveThreadLightDumpRes::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadLightDumpRes.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PCmdActiveThreadLightDumpRes::release_type() {
  // @@protoc_insertion_point(field_release:v1.PCmdActiveThreadLightDumpRes.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PCmdActiveThreadLightDumpRes::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdActiveThreadLightDumpRes.type)
}

// string subType = 4;
inline void PCmdActiveThreadLightDumpRes::clear_subtype() {
  subtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PCmdActiveThreadLightDumpRes::subtype() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadLightDumpRes.subType)
  return subtype_.GetNoArena();
}
inline void PCmdActiveThreadLightDumpRes::set_subtype(const ::std::string& value) {
  
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadLightDumpRes.subType)
}
#if LANG_CXX11
inline void PCmdActiveThreadLightDumpRes::set_subtype(::std::string&& value) {
  
  subtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PCmdActiveThreadLightDumpRes.subType)
}
#endif
inline void PCmdActiveThreadLightDumpRes::set_subtype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PCmdActiveThreadLightDumpRes.subType)
}
inline void PCmdActiveThreadLightDumpRes::set_subtype(const char* value, size_t size) {
  
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdActiveThreadLightDumpRes.subType)
}
inline ::std::string* PCmdActiveThreadLightDumpRes::mutable_subtype() {
  
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadLightDumpRes.subType)
  return subtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PCmdActiveThreadLightDumpRes::release_subtype() {
  // @@protoc_insertion_point(field_release:v1.PCmdActiveThreadLightDumpRes.subType)
  
  return subtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PCmdActiveThreadLightDumpRes::set_allocated_subtype(::std::string* subtype) {
  if (subtype != nullptr) {
    
  } else {
    
  }
  subtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subtype);
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdActiveThreadLightDumpRes.subType)
}

// string version = 5;
inline void PCmdActiveThreadLightDumpRes::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PCmdActiveThreadLightDumpRes::version() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadLightDumpRes.version)
  return version_.GetNoArena();
}
inline void PCmdActiveThreadLightDumpRes::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadLightDumpRes.version)
}
#if LANG_CXX11
inline void PCmdActiveThreadLightDumpRes::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.PCmdActiveThreadLightDumpRes.version)
}
#endif
inline void PCmdActiveThreadLightDumpRes::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.PCmdActiveThreadLightDumpRes.version)
}
inline void PCmdActiveThreadLightDumpRes::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.PCmdActiveThreadLightDumpRes.version)
}
inline ::std::string* PCmdActiveThreadLightDumpRes::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadLightDumpRes.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PCmdActiveThreadLightDumpRes::release_version() {
  // @@protoc_insertion_point(field_release:v1.PCmdActiveThreadLightDumpRes.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PCmdActiveThreadLightDumpRes::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdActiveThreadLightDumpRes.version)
}

// -------------------------------------------------------------------

// PCmdActiveThreadCount

// -------------------------------------------------------------------

// PCmdActiveThreadCountRes

// .v1.PCmdStreamResponse commonStreamResponse = 1;
inline bool PCmdActiveThreadCountRes::has_commonstreamresponse() const {
  return this != internal_default_instance() && commonstreamresponse_ != nullptr;
}
inline void PCmdActiveThreadCountRes::clear_commonstreamresponse() {
  if (GetArenaNoVirtual() == nullptr && commonstreamresponse_ != nullptr) {
    delete commonstreamresponse_;
  }
  commonstreamresponse_ = nullptr;
}
inline const ::v1::PCmdStreamResponse& PCmdActiveThreadCountRes::commonstreamresponse() const {
  const ::v1::PCmdStreamResponse* p = commonstreamresponse_;
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadCountRes.commonStreamResponse)
  return p != nullptr ? *p : *reinterpret_cast<const ::v1::PCmdStreamResponse*>(
      &::v1::_PCmdStreamResponse_default_instance_);
}
inline ::v1::PCmdStreamResponse* PCmdActiveThreadCountRes::release_commonstreamresponse() {
  // @@protoc_insertion_point(field_release:v1.PCmdActiveThreadCountRes.commonStreamResponse)
  
  ::v1::PCmdStreamResponse* temp = commonstreamresponse_;
  commonstreamresponse_ = nullptr;
  return temp;
}
inline ::v1::PCmdStreamResponse* PCmdActiveThreadCountRes::mutable_commonstreamresponse() {
  
  if (commonstreamresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::PCmdStreamResponse>(GetArenaNoVirtual());
    commonstreamresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:v1.PCmdActiveThreadCountRes.commonStreamResponse)
  return commonstreamresponse_;
}
inline void PCmdActiveThreadCountRes::set_allocated_commonstreamresponse(::v1::PCmdStreamResponse* commonstreamresponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete commonstreamresponse_;
  }
  if (commonstreamresponse) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      commonstreamresponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, commonstreamresponse, submessage_arena);
    }
    
  } else {
    
  }
  commonstreamresponse_ = commonstreamresponse;
  // @@protoc_insertion_point(field_set_allocated:v1.PCmdActiveThreadCountRes.commonStreamResponse)
}

// int32 histogramSchemaType = 2;
inline void PCmdActiveThreadCountRes::clear_histogramschematype() {
  histogramschematype_ = 0;
}
inline ::google::protobuf::int32 PCmdActiveThreadCountRes::histogramschematype() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadCountRes.histogramSchemaType)
  return histogramschematype_;
}
inline void PCmdActiveThreadCountRes::set_histogramschematype(::google::protobuf::int32 value) {
  
  histogramschematype_ = value;
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadCountRes.histogramSchemaType)
}

// repeated int32 activeThreadCount = 3;
inline int PCmdActiveThreadCountRes::activethreadcount_size() const {
  return activethreadcount_.size();
}
inline void PCmdActiveThreadCountRes::clear_activethreadcount() {
  activethreadcount_.Clear();
}
inline ::google::protobuf::int32 PCmdActiveThreadCountRes::activethreadcount(int index) const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadCountRes.activeThreadCount)
  return activethreadcount_.Get(index);
}
inline void PCmdActiveThreadCountRes::set_activethreadcount(int index, ::google::protobuf::int32 value) {
  activethreadcount_.Set(index, value);
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadCountRes.activeThreadCount)
}
inline void PCmdActiveThreadCountRes::add_activethreadcount(::google::protobuf::int32 value) {
  activethreadcount_.Add(value);
  // @@protoc_insertion_point(field_add:v1.PCmdActiveThreadCountRes.activeThreadCount)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PCmdActiveThreadCountRes::activethreadcount() const {
  // @@protoc_insertion_point(field_list:v1.PCmdActiveThreadCountRes.activeThreadCount)
  return activethreadcount_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PCmdActiveThreadCountRes::mutable_activethreadcount() {
  // @@protoc_insertion_point(field_mutable_list:v1.PCmdActiveThreadCountRes.activeThreadCount)
  return &activethreadcount_;
}

// int64 timeStamp = 4;
inline void PCmdActiveThreadCountRes::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PCmdActiveThreadCountRes::timestamp() const {
  // @@protoc_insertion_point(field_get:v1.PCmdActiveThreadCountRes.timeStamp)
  return timestamp_;
}
inline void PCmdActiveThreadCountRes::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:v1.PCmdActiveThreadCountRes.timeStamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::v1::PCommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::PCommandType>() {
  return ::v1::PCommandType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_Cmd_2eproto
