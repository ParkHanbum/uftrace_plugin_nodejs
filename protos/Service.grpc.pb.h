// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: Service.proto
#ifndef GRPC_Service_2eproto__INCLUDED
#define GRPC_Service_2eproto__INCLUDED

#include "Service.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace v1 {

class Span final {
 public:
  static constexpr char const* service_full_name() {
    return "v1.Span";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientWriterInterface< ::v1::PSpanMessage>> SendSpan(::grpc::ClientContext* context, ::google::protobuf::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::v1::PSpanMessage>>(SendSpanRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PSpanMessage>> AsyncSendSpan(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PSpanMessage>>(AsyncSendSpanRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PSpanMessage>> PrepareAsyncSendSpan(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PSpanMessage>>(PrepareAsyncSendSpanRaw(context, response, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void SendSpan(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::experimental::ClientWriteReactor< ::v1::PSpanMessage>* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientWriterInterface< ::v1::PSpanMessage>* SendSpanRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::v1::PSpanMessage>* AsyncSendSpanRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::v1::PSpanMessage>* PrepareAsyncSendSpanRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientWriter< ::v1::PSpanMessage>> SendSpan(::grpc::ClientContext* context, ::google::protobuf::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::v1::PSpanMessage>>(SendSpanRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PSpanMessage>> AsyncSendSpan(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PSpanMessage>>(AsyncSendSpanRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PSpanMessage>> PrepareAsyncSendSpan(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PSpanMessage>>(PrepareAsyncSendSpanRaw(context, response, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SendSpan(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::experimental::ClientWriteReactor< ::v1::PSpanMessage>* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientWriter< ::v1::PSpanMessage>* SendSpanRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response) override;
    ::grpc::ClientAsyncWriter< ::v1::PSpanMessage>* AsyncSendSpanRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::v1::PSpanMessage>* PrepareAsyncSendSpanRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SendSpan_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SendSpan(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PSpanMessage>* reader, ::google::protobuf::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SendSpan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SendSpan() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SendSpan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSpan(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PSpanMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendSpan(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::google::protobuf::Empty, ::v1::PSpanMessage>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SendSpan<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendSpan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SendSpan() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackClientStreamingHandler< ::v1::PSpanMessage, ::google::protobuf::Empty>(
          [this] { return this->SendSpan(); }));
    }
    ~ExperimentalWithCallbackMethod_SendSpan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSpan(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PSpanMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::v1::PSpanMessage, ::google::protobuf::Empty>* SendSpan() {
      return new ::grpc_impl::internal::UnimplementedReadReactor<
        ::v1::PSpanMessage, ::google::protobuf::Empty>;}
  };
  typedef ExperimentalWithCallbackMethod_SendSpan<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SendSpan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SendSpan() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SendSpan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSpan(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PSpanMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendSpan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SendSpan() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SendSpan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSpan(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PSpanMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendSpan(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendSpan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SendSpan() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->SendSpan(); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendSpan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSpan(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PSpanMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SendSpan() {
      return new ::grpc_impl::internal::UnimplementedReadReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  typedef Service StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef Service StreamedService;
};

class Agent final {
 public:
  static constexpr char const* service_full_name() {
    return "v1.Agent";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status RequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::v1::PResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>> AsyncRequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>>(AsyncRequestAgentInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>> PrepareAsyncRequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>>(PrepareAsyncRequestAgentInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::v1::PPing, ::v1::PPing>> PingSession(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::v1::PPing, ::v1::PPing>>(PingSessionRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::v1::PPing, ::v1::PPing>> AsyncPingSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::v1::PPing, ::v1::PPing>>(AsyncPingSessionRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::v1::PPing, ::v1::PPing>> PrepareAsyncPingSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::v1::PPing, ::v1::PPing>>(PrepareAsyncPingSessionRaw(context, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void RequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestAgentInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RequestAgentInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void PingSession(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::v1::PPing,::v1::PPing>* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>* AsyncRequestAgentInfoRaw(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>* PrepareAsyncRequestAgentInfoRaw(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::v1::PPing, ::v1::PPing>* PingSessionRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::v1::PPing, ::v1::PPing>* AsyncPingSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::v1::PPing, ::v1::PPing>* PrepareAsyncPingSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status RequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::v1::PResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>> AsyncRequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>>(AsyncRequestAgentInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>> PrepareAsyncRequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>>(PrepareAsyncRequestAgentInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::v1::PPing, ::v1::PPing>> PingSession(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::v1::PPing, ::v1::PPing>>(PingSessionRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::v1::PPing, ::v1::PPing>> AsyncPingSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::v1::PPing, ::v1::PPing>>(AsyncPingSessionRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::v1::PPing, ::v1::PPing>> PrepareAsyncPingSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::v1::PPing, ::v1::PPing>>(PrepareAsyncPingSessionRaw(context, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void RequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) override;
      void RequestAgentInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) override;
      void RequestAgentInfo(::grpc::ClientContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RequestAgentInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PingSession(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::v1::PPing,::v1::PPing>* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::v1::PResult>* AsyncRequestAgentInfoRaw(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::v1::PResult>* PrepareAsyncRequestAgentInfoRaw(::grpc::ClientContext* context, const ::v1::PAgentInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::v1::PPing, ::v1::PPing>* PingSessionRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::v1::PPing, ::v1::PPing>* AsyncPingSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::v1::PPing, ::v1::PPing>* PrepareAsyncPingSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_RequestAgentInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_PingSession_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status RequestAgentInfo(::grpc::ServerContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response);
    virtual ::grpc::Status PingSession(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PPing, ::v1::PPing>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestAgentInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RequestAgentInfo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_RequestAgentInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAgentInfo(::grpc::ServerContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestAgentInfo(::grpc::ServerContext* context, ::v1::PAgentInfo* request, ::grpc::ServerAsyncResponseWriter< ::v1::PResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PingSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_PingSession() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PingSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingSession(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PPing, ::v1::PPing>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPingSession(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::v1::PPing, ::v1::PPing>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_RequestAgentInfo<WithAsyncMethod_PingSession<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RequestAgentInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RequestAgentInfo() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::v1::PAgentInfo, ::v1::PResult>(
          [this](::grpc::ServerContext* context,
                 const ::v1::PAgentInfo* request,
                 ::v1::PResult* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RequestAgentInfo(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RequestAgentInfo(
        ::grpc::experimental::MessageAllocator< ::v1::PAgentInfo, ::v1::PResult>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::v1::PAgentInfo, ::v1::PResult>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RequestAgentInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAgentInfo(::grpc::ServerContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RequestAgentInfo(::grpc::ServerContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PingSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_PingSession() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackBidiHandler< ::v1::PPing, ::v1::PPing>(
          [this] { return this->PingSession(); }));
    }
    ~ExperimentalWithCallbackMethod_PingSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingSession(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PPing, ::v1::PPing>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::v1::PPing, ::v1::PPing>* PingSession() {
      return new ::grpc_impl::internal::UnimplementedBidiReactor<
        ::v1::PPing, ::v1::PPing>;}
  };
  typedef ExperimentalWithCallbackMethod_RequestAgentInfo<ExperimentalWithCallbackMethod_PingSession<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_RequestAgentInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RequestAgentInfo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_RequestAgentInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAgentInfo(::grpc::ServerContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PingSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_PingSession() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PingSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingSession(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PPing, ::v1::PPing>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestAgentInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RequestAgentInfo() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_RequestAgentInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAgentInfo(::grpc::ServerContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestAgentInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PingSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_PingSession() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PingSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingSession(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PPing, ::v1::PPing>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPingSession(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RequestAgentInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RequestAgentInfo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RequestAgentInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RequestAgentInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAgentInfo(::grpc::ServerContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RequestAgentInfo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PingSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_PingSession() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->PingSession(); }));
    }
    ~ExperimentalWithRawCallbackMethod_PingSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingSession(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PPing, ::v1::PPing>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* PingSession() {
      return new ::grpc_impl::internal::UnimplementedBidiReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestAgentInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RequestAgentInfo() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::v1::PAgentInfo, ::v1::PResult>(std::bind(&WithStreamedUnaryMethod_RequestAgentInfo<BaseClass>::StreamedRequestAgentInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RequestAgentInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestAgentInfo(::grpc::ServerContext* context, const ::v1::PAgentInfo* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestAgentInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::v1::PAgentInfo,::v1::PResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_RequestAgentInfo<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_RequestAgentInfo<Service > StreamedService;
};

class Metadata final {
 public:
  static constexpr char const* service_full_name() {
    return "v1.Metadata";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status RequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::v1::PResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>> AsyncRequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>>(AsyncRequestSqlMetaDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>> PrepareAsyncRequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>>(PrepareAsyncRequestSqlMetaDataRaw(context, request, cq));
    }
    virtual ::grpc::Status RequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::v1::PResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>> AsyncRequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>>(AsyncRequestApiMetaDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>> PrepareAsyncRequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>>(PrepareAsyncRequestApiMetaDataRaw(context, request, cq));
    }
    virtual ::grpc::Status RequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::v1::PResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>> AsyncRequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>>(AsyncRequestStringMetaDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>> PrepareAsyncRequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>>(PrepareAsyncRequestStringMetaDataRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void RequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestSqlMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RequestSqlMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestApiMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RequestApiMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestStringMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RequestStringMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>* AsyncRequestSqlMetaDataRaw(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>* PrepareAsyncRequestSqlMetaDataRaw(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>* AsyncRequestApiMetaDataRaw(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>* PrepareAsyncRequestApiMetaDataRaw(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>* AsyncRequestStringMetaDataRaw(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::v1::PResult>* PrepareAsyncRequestStringMetaDataRaw(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status RequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::v1::PResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>> AsyncRequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>>(AsyncRequestSqlMetaDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>> PrepareAsyncRequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>>(PrepareAsyncRequestSqlMetaDataRaw(context, request, cq));
    }
    ::grpc::Status RequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::v1::PResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>> AsyncRequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>>(AsyncRequestApiMetaDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>> PrepareAsyncRequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>>(PrepareAsyncRequestApiMetaDataRaw(context, request, cq));
    }
    ::grpc::Status RequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::v1::PResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>> AsyncRequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>>(AsyncRequestStringMetaDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>> PrepareAsyncRequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::v1::PResult>>(PrepareAsyncRequestStringMetaDataRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void RequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) override;
      void RequestSqlMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) override;
      void RequestSqlMetaData(::grpc::ClientContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RequestSqlMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) override;
      void RequestApiMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) override;
      void RequestApiMetaData(::grpc::ClientContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RequestApiMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) override;
      void RequestStringMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, std::function<void(::grpc::Status)>) override;
      void RequestStringMetaData(::grpc::ClientContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RequestStringMetaData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::v1::PResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::v1::PResult>* AsyncRequestSqlMetaDataRaw(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::v1::PResult>* PrepareAsyncRequestSqlMetaDataRaw(::grpc::ClientContext* context, const ::v1::PSqlMetaData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::v1::PResult>* AsyncRequestApiMetaDataRaw(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::v1::PResult>* PrepareAsyncRequestApiMetaDataRaw(::grpc::ClientContext* context, const ::v1::PApiMetaData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::v1::PResult>* AsyncRequestStringMetaDataRaw(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::v1::PResult>* PrepareAsyncRequestStringMetaDataRaw(::grpc::ClientContext* context, const ::v1::PStringMetaData& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_RequestSqlMetaData_;
    const ::grpc::internal::RpcMethod rpcmethod_RequestApiMetaData_;
    const ::grpc::internal::RpcMethod rpcmethod_RequestStringMetaData_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status RequestSqlMetaData(::grpc::ServerContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response);
    virtual ::grpc::Status RequestApiMetaData(::grpc::ServerContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response);
    virtual ::grpc::Status RequestStringMetaData(::grpc::ServerContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestSqlMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RequestSqlMetaData() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_RequestSqlMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSqlMetaData(::grpc::ServerContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestSqlMetaData(::grpc::ServerContext* context, ::v1::PSqlMetaData* request, ::grpc::ServerAsyncResponseWriter< ::v1::PResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestApiMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RequestApiMetaData() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_RequestApiMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestApiMetaData(::grpc::ServerContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestApiMetaData(::grpc::ServerContext* context, ::v1::PApiMetaData* request, ::grpc::ServerAsyncResponseWriter< ::v1::PResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestStringMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RequestStringMetaData() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_RequestStringMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestStringMetaData(::grpc::ServerContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestStringMetaData(::grpc::ServerContext* context, ::v1::PStringMetaData* request, ::grpc::ServerAsyncResponseWriter< ::v1::PResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_RequestSqlMetaData<WithAsyncMethod_RequestApiMetaData<WithAsyncMethod_RequestStringMetaData<Service > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RequestSqlMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RequestSqlMetaData() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::v1::PSqlMetaData, ::v1::PResult>(
          [this](::grpc::ServerContext* context,
                 const ::v1::PSqlMetaData* request,
                 ::v1::PResult* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RequestSqlMetaData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RequestSqlMetaData(
        ::grpc::experimental::MessageAllocator< ::v1::PSqlMetaData, ::v1::PResult>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::v1::PSqlMetaData, ::v1::PResult>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RequestSqlMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSqlMetaData(::grpc::ServerContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RequestSqlMetaData(::grpc::ServerContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RequestApiMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RequestApiMetaData() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::v1::PApiMetaData, ::v1::PResult>(
          [this](::grpc::ServerContext* context,
                 const ::v1::PApiMetaData* request,
                 ::v1::PResult* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RequestApiMetaData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RequestApiMetaData(
        ::grpc::experimental::MessageAllocator< ::v1::PApiMetaData, ::v1::PResult>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::v1::PApiMetaData, ::v1::PResult>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RequestApiMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestApiMetaData(::grpc::ServerContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RequestApiMetaData(::grpc::ServerContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RequestStringMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RequestStringMetaData() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::v1::PStringMetaData, ::v1::PResult>(
          [this](::grpc::ServerContext* context,
                 const ::v1::PStringMetaData* request,
                 ::v1::PResult* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RequestStringMetaData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RequestStringMetaData(
        ::grpc::experimental::MessageAllocator< ::v1::PStringMetaData, ::v1::PResult>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::v1::PStringMetaData, ::v1::PResult>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RequestStringMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestStringMetaData(::grpc::ServerContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RequestStringMetaData(::grpc::ServerContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_RequestSqlMetaData<ExperimentalWithCallbackMethod_RequestApiMetaData<ExperimentalWithCallbackMethod_RequestStringMetaData<Service > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_RequestSqlMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RequestSqlMetaData() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_RequestSqlMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSqlMetaData(::grpc::ServerContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RequestApiMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RequestApiMetaData() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RequestApiMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestApiMetaData(::grpc::ServerContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RequestStringMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RequestStringMetaData() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_RequestStringMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestStringMetaData(::grpc::ServerContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestSqlMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RequestSqlMetaData() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_RequestSqlMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSqlMetaData(::grpc::ServerContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestSqlMetaData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestApiMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RequestApiMetaData() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_RequestApiMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestApiMetaData(::grpc::ServerContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestApiMetaData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestStringMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RequestStringMetaData() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_RequestStringMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestStringMetaData(::grpc::ServerContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestStringMetaData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RequestSqlMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RequestSqlMetaData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RequestSqlMetaData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RequestSqlMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSqlMetaData(::grpc::ServerContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RequestSqlMetaData(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RequestApiMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RequestApiMetaData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RequestApiMetaData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RequestApiMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestApiMetaData(::grpc::ServerContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RequestApiMetaData(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RequestStringMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RequestStringMetaData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RequestStringMetaData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RequestStringMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestStringMetaData(::grpc::ServerContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RequestStringMetaData(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestSqlMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RequestSqlMetaData() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::v1::PSqlMetaData, ::v1::PResult>(std::bind(&WithStreamedUnaryMethod_RequestSqlMetaData<BaseClass>::StreamedRequestSqlMetaData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RequestSqlMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestSqlMetaData(::grpc::ServerContext* context, const ::v1::PSqlMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestSqlMetaData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::v1::PSqlMetaData,::v1::PResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestApiMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RequestApiMetaData() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::v1::PApiMetaData, ::v1::PResult>(std::bind(&WithStreamedUnaryMethod_RequestApiMetaData<BaseClass>::StreamedRequestApiMetaData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RequestApiMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestApiMetaData(::grpc::ServerContext* context, const ::v1::PApiMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestApiMetaData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::v1::PApiMetaData,::v1::PResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestStringMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RequestStringMetaData() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::v1::PStringMetaData, ::v1::PResult>(std::bind(&WithStreamedUnaryMethod_RequestStringMetaData<BaseClass>::StreamedRequestStringMetaData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RequestStringMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestStringMetaData(::grpc::ServerContext* context, const ::v1::PStringMetaData* request, ::v1::PResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestStringMetaData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::v1::PStringMetaData,::v1::PResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_RequestSqlMetaData<WithStreamedUnaryMethod_RequestApiMetaData<WithStreamedUnaryMethod_RequestStringMetaData<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_RequestSqlMetaData<WithStreamedUnaryMethod_RequestApiMetaData<WithStreamedUnaryMethod_RequestStringMetaData<Service > > > StreamedService;
};

class Stat final {
 public:
  static constexpr char const* service_full_name() {
    return "v1.Stat";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientWriterInterface< ::v1::PStatMessage>> SendAgentStat(::grpc::ClientContext* context, ::google::protobuf::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::v1::PStatMessage>>(SendAgentStatRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PStatMessage>> AsyncSendAgentStat(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PStatMessage>>(AsyncSendAgentStatRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PStatMessage>> PrepareAsyncSendAgentStat(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PStatMessage>>(PrepareAsyncSendAgentStatRaw(context, response, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void SendAgentStat(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::experimental::ClientWriteReactor< ::v1::PStatMessage>* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientWriterInterface< ::v1::PStatMessage>* SendAgentStatRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::v1::PStatMessage>* AsyncSendAgentStatRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::v1::PStatMessage>* PrepareAsyncSendAgentStatRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientWriter< ::v1::PStatMessage>> SendAgentStat(::grpc::ClientContext* context, ::google::protobuf::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::v1::PStatMessage>>(SendAgentStatRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PStatMessage>> AsyncSendAgentStat(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PStatMessage>>(AsyncSendAgentStatRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PStatMessage>> PrepareAsyncSendAgentStat(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PStatMessage>>(PrepareAsyncSendAgentStatRaw(context, response, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SendAgentStat(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::experimental::ClientWriteReactor< ::v1::PStatMessage>* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientWriter< ::v1::PStatMessage>* SendAgentStatRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response) override;
    ::grpc::ClientAsyncWriter< ::v1::PStatMessage>* AsyncSendAgentStatRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::v1::PStatMessage>* PrepareAsyncSendAgentStatRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SendAgentStat_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SendAgentStat(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PStatMessage>* reader, ::google::protobuf::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SendAgentStat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SendAgentStat() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SendAgentStat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAgentStat(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PStatMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendAgentStat(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::google::protobuf::Empty, ::v1::PStatMessage>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SendAgentStat<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendAgentStat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SendAgentStat() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackClientStreamingHandler< ::v1::PStatMessage, ::google::protobuf::Empty>(
          [this] { return this->SendAgentStat(); }));
    }
    ~ExperimentalWithCallbackMethod_SendAgentStat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAgentStat(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PStatMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::v1::PStatMessage, ::google::protobuf::Empty>* SendAgentStat() {
      return new ::grpc_impl::internal::UnimplementedReadReactor<
        ::v1::PStatMessage, ::google::protobuf::Empty>;}
  };
  typedef ExperimentalWithCallbackMethod_SendAgentStat<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SendAgentStat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SendAgentStat() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SendAgentStat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAgentStat(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PStatMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendAgentStat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SendAgentStat() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SendAgentStat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAgentStat(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PStatMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendAgentStat(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendAgentStat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SendAgentStat() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->SendAgentStat(); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendAgentStat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAgentStat(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PStatMessage>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SendAgentStat() {
      return new ::grpc_impl::internal::UnimplementedReadReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  typedef Service StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef Service StreamedService;
};

class ProfilerCommandService final {
 public:
  static constexpr char const* service_full_name() {
    return "v1.ProfilerCommandService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::v1::PCmdMessage, ::v1::PCmdRequest>> HandleCommand(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::v1::PCmdMessage, ::v1::PCmdRequest>>(HandleCommandRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::v1::PCmdMessage, ::v1::PCmdRequest>> AsyncHandleCommand(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::v1::PCmdMessage, ::v1::PCmdRequest>>(AsyncHandleCommandRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::v1::PCmdMessage, ::v1::PCmdRequest>> PrepareAsyncHandleCommand(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::v1::PCmdMessage, ::v1::PCmdRequest>>(PrepareAsyncHandleCommandRaw(context, cq));
    }
    virtual ::grpc::Status CommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncCommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncCommandEchoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncCommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncCommandEchoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriterInterface< ::v1::PCmdActiveThreadCountRes>> CommandStreamActiveThreadCount(::grpc::ClientContext* context, ::google::protobuf::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::v1::PCmdActiveThreadCountRes>>(CommandStreamActiveThreadCountRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PCmdActiveThreadCountRes>> AsyncCommandStreamActiveThreadCount(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PCmdActiveThreadCountRes>>(AsyncCommandStreamActiveThreadCountRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PCmdActiveThreadCountRes>> PrepareAsyncCommandStreamActiveThreadCount(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::v1::PCmdActiveThreadCountRes>>(PrepareAsyncCommandStreamActiveThreadCountRaw(context, response, cq));
    }
    virtual ::grpc::Status CommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncCommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncCommandActiveThreadDumpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncCommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncCommandActiveThreadDumpRaw(context, request, cq));
    }
    virtual ::grpc::Status CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncCommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncCommandActiveThreadLightDumpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncCommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncCommandActiveThreadLightDumpRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void HandleCommand(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::v1::PCmdMessage,::v1::PCmdRequest>* reactor) = 0;
      virtual void CommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CommandEcho(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CommandEcho(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CommandStreamActiveThreadCount(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::experimental::ClientWriteReactor< ::v1::PCmdActiveThreadCountRes>* reactor) = 0;
      virtual void CommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CommandActiveThreadDump(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CommandActiveThreadDump(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderWriterInterface< ::v1::PCmdMessage, ::v1::PCmdRequest>* HandleCommandRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::v1::PCmdMessage, ::v1::PCmdRequest>* AsyncHandleCommandRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::v1::PCmdMessage, ::v1::PCmdRequest>* PrepareAsyncHandleCommandRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncCommandEchoRaw(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncCommandEchoRaw(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::v1::PCmdActiveThreadCountRes>* CommandStreamActiveThreadCountRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::v1::PCmdActiveThreadCountRes>* AsyncCommandStreamActiveThreadCountRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::v1::PCmdActiveThreadCountRes>* PrepareAsyncCommandStreamActiveThreadCountRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncCommandActiveThreadDumpRaw(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncCommandActiveThreadDumpRaw(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncCommandActiveThreadLightDumpRaw(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncCommandActiveThreadLightDumpRaw(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReaderWriter< ::v1::PCmdMessage, ::v1::PCmdRequest>> HandleCommand(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::v1::PCmdMessage, ::v1::PCmdRequest>>(HandleCommandRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::v1::PCmdMessage, ::v1::PCmdRequest>> AsyncHandleCommand(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::v1::PCmdMessage, ::v1::PCmdRequest>>(AsyncHandleCommandRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::v1::PCmdMessage, ::v1::PCmdRequest>> PrepareAsyncHandleCommand(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::v1::PCmdMessage, ::v1::PCmdRequest>>(PrepareAsyncHandleCommandRaw(context, cq));
    }
    ::grpc::Status CommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncCommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncCommandEchoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncCommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncCommandEchoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::v1::PCmdActiveThreadCountRes>> CommandStreamActiveThreadCount(::grpc::ClientContext* context, ::google::protobuf::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::v1::PCmdActiveThreadCountRes>>(CommandStreamActiveThreadCountRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PCmdActiveThreadCountRes>> AsyncCommandStreamActiveThreadCount(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PCmdActiveThreadCountRes>>(AsyncCommandStreamActiveThreadCountRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PCmdActiveThreadCountRes>> PrepareAsyncCommandStreamActiveThreadCount(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::v1::PCmdActiveThreadCountRes>>(PrepareAsyncCommandStreamActiveThreadCountRaw(context, response, cq));
    }
    ::grpc::Status CommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncCommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncCommandActiveThreadDumpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncCommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncCommandActiveThreadDumpRaw(context, request, cq));
    }
    ::grpc::Status CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncCommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncCommandActiveThreadLightDumpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncCommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncCommandActiveThreadLightDumpRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void HandleCommand(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::v1::PCmdMessage,::v1::PCmdRequest>* reactor) override;
      void CommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void CommandEcho(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void CommandEcho(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CommandEcho(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CommandStreamActiveThreadCount(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::experimental::ClientWriteReactor< ::v1::PCmdActiveThreadCountRes>* reactor) override;
      void CommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void CommandActiveThreadDump(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void CommandActiveThreadDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CommandActiveThreadDump(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CommandActiveThreadLightDump(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReaderWriter< ::v1::PCmdMessage, ::v1::PCmdRequest>* HandleCommandRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::v1::PCmdMessage, ::v1::PCmdRequest>* AsyncHandleCommandRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::v1::PCmdMessage, ::v1::PCmdRequest>* PrepareAsyncHandleCommandRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncCommandEchoRaw(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncCommandEchoRaw(::grpc::ClientContext* context, const ::v1::PCmdEchoResponse& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::v1::PCmdActiveThreadCountRes>* CommandStreamActiveThreadCountRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response) override;
    ::grpc::ClientAsyncWriter< ::v1::PCmdActiveThreadCountRes>* AsyncCommandStreamActiveThreadCountRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::v1::PCmdActiveThreadCountRes>* PrepareAsyncCommandStreamActiveThreadCountRaw(::grpc::ClientContext* context, ::google::protobuf::Empty* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncCommandActiveThreadDumpRaw(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncCommandActiveThreadDumpRaw(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadDumpRes& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncCommandActiveThreadLightDumpRaw(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncCommandActiveThreadLightDumpRaw(::grpc::ClientContext* context, const ::v1::PCmdActiveThreadLightDumpRes& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_HandleCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_CommandEcho_;
    const ::grpc::internal::RpcMethod rpcmethod_CommandStreamActiveThreadCount_;
    const ::grpc::internal::RpcMethod rpcmethod_CommandActiveThreadDump_;
    const ::grpc::internal::RpcMethod rpcmethod_CommandActiveThreadLightDump_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status HandleCommand(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PCmdRequest, ::v1::PCmdMessage>* stream);
    virtual ::grpc::Status CommandEcho(::grpc::ServerContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status CommandStreamActiveThreadCount(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PCmdActiveThreadCountRes>* reader, ::google::protobuf::Empty* response);
    virtual ::grpc::Status CommandActiveThreadDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status CommandActiveThreadLightDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_HandleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HandleCommand() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_HandleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleCommand(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PCmdRequest, ::v1::PCmdMessage>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandleCommand(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::v1::PCmdRequest, ::v1::PCmdMessage>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CommandEcho : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CommandEcho() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CommandEcho() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandEcho(::grpc::ServerContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommandEcho(::grpc::ServerContext* context, ::v1::PCmdEchoResponse* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CommandStreamActiveThreadCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CommandStreamActiveThreadCount() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_CommandStreamActiveThreadCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandStreamActiveThreadCount(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PCmdActiveThreadCountRes>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommandStreamActiveThreadCount(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::google::protobuf::Empty, ::v1::PCmdActiveThreadCountRes>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CommandActiveThreadDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CommandActiveThreadDump() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_CommandActiveThreadDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommandActiveThreadDump(::grpc::ServerContext* context, ::v1::PCmdActiveThreadDumpRes* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CommandActiveThreadLightDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CommandActiveThreadLightDump() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CommandActiveThreadLightDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadLightDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommandActiveThreadLightDump(::grpc::ServerContext* context, ::v1::PCmdActiveThreadLightDumpRes* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_HandleCommand<WithAsyncMethod_CommandEcho<WithAsyncMethod_CommandStreamActiveThreadCount<WithAsyncMethod_CommandActiveThreadDump<WithAsyncMethod_CommandActiveThreadLightDump<Service > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HandleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_HandleCommand() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackBidiHandler< ::v1::PCmdMessage, ::v1::PCmdRequest>(
          [this] { return this->HandleCommand(); }));
    }
    ~ExperimentalWithCallbackMethod_HandleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleCommand(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PCmdRequest, ::v1::PCmdMessage>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::v1::PCmdMessage, ::v1::PCmdRequest>* HandleCommand() {
      return new ::grpc_impl::internal::UnimplementedBidiReactor<
        ::v1::PCmdMessage, ::v1::PCmdRequest>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CommandEcho : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CommandEcho() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::v1::PCmdEchoResponse, ::google::protobuf::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::v1::PCmdEchoResponse* request,
                 ::google::protobuf::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CommandEcho(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CommandEcho(
        ::grpc::experimental::MessageAllocator< ::v1::PCmdEchoResponse, ::google::protobuf::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::v1::PCmdEchoResponse, ::google::protobuf::Empty>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CommandEcho() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandEcho(::grpc::ServerContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CommandEcho(::grpc::ServerContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CommandStreamActiveThreadCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CommandStreamActiveThreadCount() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackClientStreamingHandler< ::v1::PCmdActiveThreadCountRes, ::google::protobuf::Empty>(
          [this] { return this->CommandStreamActiveThreadCount(); }));
    }
    ~ExperimentalWithCallbackMethod_CommandStreamActiveThreadCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandStreamActiveThreadCount(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PCmdActiveThreadCountRes>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::v1::PCmdActiveThreadCountRes, ::google::protobuf::Empty>* CommandStreamActiveThreadCount() {
      return new ::grpc_impl::internal::UnimplementedReadReactor<
        ::v1::PCmdActiveThreadCountRes, ::google::protobuf::Empty>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CommandActiveThreadDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CommandActiveThreadDump() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::v1::PCmdActiveThreadDumpRes, ::google::protobuf::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::v1::PCmdActiveThreadDumpRes* request,
                 ::google::protobuf::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CommandActiveThreadDump(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CommandActiveThreadDump(
        ::grpc::experimental::MessageAllocator< ::v1::PCmdActiveThreadDumpRes, ::google::protobuf::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::v1::PCmdActiveThreadDumpRes, ::google::protobuf::Empty>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CommandActiveThreadDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CommandActiveThreadDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CommandActiveThreadLightDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CommandActiveThreadLightDump() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::v1::PCmdActiveThreadLightDumpRes, ::google::protobuf::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::v1::PCmdActiveThreadLightDumpRes* request,
                 ::google::protobuf::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CommandActiveThreadLightDump(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CommandActiveThreadLightDump(
        ::grpc::experimental::MessageAllocator< ::v1::PCmdActiveThreadLightDumpRes, ::google::protobuf::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::v1::PCmdActiveThreadLightDumpRes, ::google::protobuf::Empty>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CommandActiveThreadLightDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadLightDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CommandActiveThreadLightDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_HandleCommand<ExperimentalWithCallbackMethod_CommandEcho<ExperimentalWithCallbackMethod_CommandStreamActiveThreadCount<ExperimentalWithCallbackMethod_CommandActiveThreadDump<ExperimentalWithCallbackMethod_CommandActiveThreadLightDump<Service > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_HandleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HandleCommand() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_HandleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleCommand(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PCmdRequest, ::v1::PCmdMessage>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CommandEcho : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CommandEcho() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CommandEcho() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandEcho(::grpc::ServerContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CommandStreamActiveThreadCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CommandStreamActiveThreadCount() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_CommandStreamActiveThreadCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandStreamActiveThreadCount(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PCmdActiveThreadCountRes>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CommandActiveThreadDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CommandActiveThreadDump() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_CommandActiveThreadDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CommandActiveThreadLightDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CommandActiveThreadLightDump() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CommandActiveThreadLightDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadLightDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_HandleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_HandleCommand() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_HandleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleCommand(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PCmdRequest, ::v1::PCmdMessage>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandleCommand(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CommandEcho : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CommandEcho() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CommandEcho() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandEcho(::grpc::ServerContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommandEcho(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CommandStreamActiveThreadCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CommandStreamActiveThreadCount() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_CommandStreamActiveThreadCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandStreamActiveThreadCount(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PCmdActiveThreadCountRes>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommandStreamActiveThreadCount(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CommandActiveThreadDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CommandActiveThreadDump() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_CommandActiveThreadDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommandActiveThreadDump(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CommandActiveThreadLightDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CommandActiveThreadLightDump() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CommandActiveThreadLightDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadLightDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommandActiveThreadLightDump(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HandleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_HandleCommand() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->HandleCommand(); }));
    }
    ~ExperimentalWithRawCallbackMethod_HandleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleCommand(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::v1::PCmdRequest, ::v1::PCmdMessage>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* HandleCommand() {
      return new ::grpc_impl::internal::UnimplementedBidiReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CommandEcho : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CommandEcho() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CommandEcho(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CommandEcho() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandEcho(::grpc::ServerContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CommandEcho(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CommandStreamActiveThreadCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CommandStreamActiveThreadCount() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->CommandStreamActiveThreadCount(); }));
    }
    ~ExperimentalWithRawCallbackMethod_CommandStreamActiveThreadCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandStreamActiveThreadCount(::grpc::ServerContext* context, ::grpc::ServerReader< ::v1::PCmdActiveThreadCountRes>* reader, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* CommandStreamActiveThreadCount() {
      return new ::grpc_impl::internal::UnimplementedReadReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CommandActiveThreadDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CommandActiveThreadDump() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CommandActiveThreadDump(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CommandActiveThreadDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CommandActiveThreadDump(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CommandActiveThreadLightDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CommandActiveThreadLightDump() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CommandActiveThreadLightDump(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CommandActiveThreadLightDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommandActiveThreadLightDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CommandActiveThreadLightDump(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CommandEcho : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CommandEcho() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::v1::PCmdEchoResponse, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_CommandEcho<BaseClass>::StreamedCommandEcho, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CommandEcho() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CommandEcho(::grpc::ServerContext* context, const ::v1::PCmdEchoResponse* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCommandEcho(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::v1::PCmdEchoResponse,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CommandActiveThreadDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CommandActiveThreadDump() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::v1::PCmdActiveThreadDumpRes, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_CommandActiveThreadDump<BaseClass>::StreamedCommandActiveThreadDump, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CommandActiveThreadDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CommandActiveThreadDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCommandActiveThreadDump(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::v1::PCmdActiveThreadDumpRes,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CommandActiveThreadLightDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CommandActiveThreadLightDump() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::v1::PCmdActiveThreadLightDumpRes, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_CommandActiveThreadLightDump<BaseClass>::StreamedCommandActiveThreadLightDump, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CommandActiveThreadLightDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CommandActiveThreadLightDump(::grpc::ServerContext* context, const ::v1::PCmdActiveThreadLightDumpRes* request, ::google::protobuf::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCommandActiveThreadLightDump(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::v1::PCmdActiveThreadLightDumpRes,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CommandEcho<WithStreamedUnaryMethod_CommandActiveThreadDump<WithStreamedUnaryMethod_CommandActiveThreadLightDump<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CommandEcho<WithStreamedUnaryMethod_CommandActiveThreadDump<WithStreamedUnaryMethod_CommandActiveThreadLightDump<Service > > > StreamedService;
};

}  // namespace v1


#endif  // GRPC_Service_2eproto__INCLUDED
